// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/question.proto

/*
	Package api is a generated protocol buffer package.

	It is generated from these files:
		api/question.proto

	It has these top-level messages:
		CRqQueryMyQuestionInfoBySubject
		CRpMyQuestionInfoBySubject
		CreateQuestionReq
		QuestionInfoReply
		QueryQuestionReq
		QueryQuestionReply
		CreateHomeWorkReq
		CreateHomeWorkReply
		QueryMyHomeWorkReq
		QuestionInfo
		HomeWorkInfo
		QueryMyHomeWorkReply
		DoQuestionInfo
		DoHomeWorkReq
		QueryAnswerRecordReq
		UserAnswerInfo
		AllUserAnswerInfo
		QueryAnswerRecordReply
		QueryHomeWorkInClassReply
		CreatePracticeSummaryReq
		CreatePracticeSummaryReply
		QueryPracticeSummaryReq
		PracticeSummaryInfo
		QuestionPre
		PracticeSummaryDetailInfo
		QueryMyPracticeSummaryReq
		QueryMyPracticeSummaryReply
		ControllQuestionInPSReq
		CreatePaperReq
		CreatePaperReply
		QueryPaperInClassReq
		QueryPaperInClassReply
		QueryPaperQuestionsReq
		QueryPaperQuestionsReply
		PaperInfo
		DoPaperReq
		QueryPaperAnswerRecordReq
		QueryPaperAnswerRecordReply
		UserPaperAnswerInfo
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "knowledgemap_backend/microservices/knowledgemap/user/api"
import _ "knowledgemap_backend/microservices/knowledgemap/class/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type PracticeSummaryType int32

const (
	PracticeSummaryType_DEFAULT    PracticeSummaryType = 0
	PracticeSummaryType_COLLECTION PracticeSummaryType = 1
	PracticeSummaryType_MISTAKES   PracticeSummaryType = 2
)

var PracticeSummaryType_name = map[int32]string{
	0: "DEFAULT",
	1: "COLLECTION",
	2: "MISTAKES",
}
var PracticeSummaryType_value = map[string]int32{
	"DEFAULT":    0,
	"COLLECTION": 1,
	"MISTAKES":   2,
}

func (x PracticeSummaryType) String() string {
	return proto.EnumName(PracticeSummaryType_name, int32(x))
}
func (PracticeSummaryType) EnumDescriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{0} }

type CRqQueryMyQuestionInfoBySubject struct {
	Uid     string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid"`
	Subject string `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject"`
	Endtime int64  `protobuf:"varint,3,opt,name=endtime,proto3" json:"endtime"`
}

func (m *CRqQueryMyQuestionInfoBySubject) Reset()         { *m = CRqQueryMyQuestionInfoBySubject{} }
func (m *CRqQueryMyQuestionInfoBySubject) String() string { return proto.CompactTextString(m) }
func (*CRqQueryMyQuestionInfoBySubject) ProtoMessage()    {}
func (*CRqQueryMyQuestionInfoBySubject) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{0}
}

func (m *CRqQueryMyQuestionInfoBySubject) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *CRqQueryMyQuestionInfoBySubject) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *CRqQueryMyQuestionInfoBySubject) GetEndtime() int64 {
	if m != nil {
		return m.Endtime
	}
	return 0
}

type CRpMyQuestionInfoBySubject struct {
	Knowledgenodes []string `protobuf:"bytes,1,rep,name=knowledgenodes" json:"knowledgenodes,omitempty"`
}

func (m *CRpMyQuestionInfoBySubject) Reset()         { *m = CRpMyQuestionInfoBySubject{} }
func (m *CRpMyQuestionInfoBySubject) String() string { return proto.CompactTextString(m) }
func (*CRpMyQuestionInfoBySubject) ProtoMessage()    {}
func (*CRpMyQuestionInfoBySubject) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{1}
}

func (m *CRpMyQuestionInfoBySubject) GetKnowledgenodes() []string {
	if m != nil {
		return m.Knowledgenodes
	}
	return nil
}

type CreateQuestionReq struct {
	Kind      int64    `protobuf:"varint,1,opt,name=kind,proto3" json:"kind,omitempty" form:"kind"`
	Name      string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Content   string   `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty" form:"content"`
	Qimage    bool     `protobuf:"varint,4,opt,name=qimage,proto3" json:"qimage,omitempty" form:"qimage"`
	Option    []string `protobuf:"bytes,5,rep,name=option" json:"option,omitempty" form:"option"`
	Oimage    bool     `protobuf:"varint,6,opt,name=oimage,proto3" json:"oimage,omitempty" form:"oimage"`
	Answer    []string `protobuf:"bytes,7,rep,name=answer" json:"answer,omitempty" form:"answer"`
	Aimage    bool     `protobuf:"varint,8,opt,name=aimage,proto3" json:"aimage,omitempty" form:"aimage"`
	Subject   string   `protobuf:"bytes,9,opt,name=subject,proto3" json:"subject,omitempty" form:"subject"`
	Course    string   `protobuf:"bytes,10,opt,name=course,proto3" json:"course,omitempty" form:"course"`
	Knowledge string   `protobuf:"bytes,11,opt,name=knowledge,proto3" json:"knowledge,omitempty" form:"knowledge"`
	Needcheck bool     `protobuf:"varint,12,opt,name=needcheck,proto3" json:"needcheck,omitempty" form:"needcheck"`
	Explain   string   `protobuf:"bytes,13,opt,name=explain,proto3" json:"explain,omitempty" form:"explain"`
	Star      int64    `protobuf:"varint,14,opt,name=star,proto3" json:"star,omitempty" form:"star"`
}

func (m *CreateQuestionReq) Reset()                    { *m = CreateQuestionReq{} }
func (m *CreateQuestionReq) String() string            { return proto.CompactTextString(m) }
func (*CreateQuestionReq) ProtoMessage()               {}
func (*CreateQuestionReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{2} }

func (m *CreateQuestionReq) GetKind() int64 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *CreateQuestionReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateQuestionReq) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *CreateQuestionReq) GetQimage() bool {
	if m != nil {
		return m.Qimage
	}
	return false
}

func (m *CreateQuestionReq) GetOption() []string {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *CreateQuestionReq) GetOimage() bool {
	if m != nil {
		return m.Oimage
	}
	return false
}

func (m *CreateQuestionReq) GetAnswer() []string {
	if m != nil {
		return m.Answer
	}
	return nil
}

func (m *CreateQuestionReq) GetAimage() bool {
	if m != nil {
		return m.Aimage
	}
	return false
}

func (m *CreateQuestionReq) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *CreateQuestionReq) GetCourse() string {
	if m != nil {
		return m.Course
	}
	return ""
}

func (m *CreateQuestionReq) GetKnowledge() string {
	if m != nil {
		return m.Knowledge
	}
	return ""
}

func (m *CreateQuestionReq) GetNeedcheck() bool {
	if m != nil {
		return m.Needcheck
	}
	return false
}

func (m *CreateQuestionReq) GetExplain() string {
	if m != nil {
		return m.Explain
	}
	return ""
}

func (m *CreateQuestionReq) GetStar() int64 {
	if m != nil {
		return m.Star
	}
	return 0
}

type QuestionInfoReply struct {
	Id        string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" form:"id"`
	Kind      int64    `protobuf:"varint,2,opt,name=kind,proto3" json:"kind,omitempty" form:"kind"`
	Content   string   `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty" form:"content"`
	Qimage    bool     `protobuf:"varint,4,opt,name=qimage,proto3" json:"qimage,omitempty" form:"qimage"`
	Option    []string `protobuf:"bytes,5,rep,name=option" json:"option,omitempty" form:"option"`
	Oimage    bool     `protobuf:"varint,6,opt,name=oimage,proto3" json:"oimage,omitempty" form:"oimage"`
	Answer    []string `protobuf:"bytes,7,rep,name=answer" json:"answer,omitempty" form:"answer"`
	Aimage    bool     `protobuf:"varint,8,opt,name=aimage,proto3" json:"aimage,omitempty" form:"aimage"`
	Subject   string   `protobuf:"bytes,9,opt,name=subject,proto3" json:"subject,omitempty" form:"subject"`
	Course    string   `protobuf:"bytes,10,opt,name=course,proto3" json:"course,omitempty" form:"course"`
	Knowledge string   `protobuf:"bytes,11,opt,name=knowledge,proto3" json:"knowledge,omitempty" form:"knowledge"`
	Name      string   `protobuf:"bytes,12,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Needcheck bool     `protobuf:"varint,13,opt,name=needcheck,proto3" json:"needcheck,omitempty" form:"needcheck"`
	Explain   string   `protobuf:"bytes,14,opt,name=explain,proto3" json:"explain,omitempty" form:"explain"`
	Star      int64    `protobuf:"varint,15,opt,name=star,proto3" json:"star,omitempty" form:"star"`
}

func (m *QuestionInfoReply) Reset()                    { *m = QuestionInfoReply{} }
func (m *QuestionInfoReply) String() string            { return proto.CompactTextString(m) }
func (*QuestionInfoReply) ProtoMessage()               {}
func (*QuestionInfoReply) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{3} }

func (m *QuestionInfoReply) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *QuestionInfoReply) GetKind() int64 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *QuestionInfoReply) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *QuestionInfoReply) GetQimage() bool {
	if m != nil {
		return m.Qimage
	}
	return false
}

func (m *QuestionInfoReply) GetOption() []string {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *QuestionInfoReply) GetOimage() bool {
	if m != nil {
		return m.Oimage
	}
	return false
}

func (m *QuestionInfoReply) GetAnswer() []string {
	if m != nil {
		return m.Answer
	}
	return nil
}

func (m *QuestionInfoReply) GetAimage() bool {
	if m != nil {
		return m.Aimage
	}
	return false
}

func (m *QuestionInfoReply) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *QuestionInfoReply) GetCourse() string {
	if m != nil {
		return m.Course
	}
	return ""
}

func (m *QuestionInfoReply) GetKnowledge() string {
	if m != nil {
		return m.Knowledge
	}
	return ""
}

func (m *QuestionInfoReply) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QuestionInfoReply) GetNeedcheck() bool {
	if m != nil {
		return m.Needcheck
	}
	return false
}

func (m *QuestionInfoReply) GetExplain() string {
	if m != nil {
		return m.Explain
	}
	return ""
}

func (m *QuestionInfoReply) GetStar() int64 {
	if m != nil {
		return m.Star
	}
	return 0
}

type QueryQuestionReq struct {
	Kind      int64  `protobuf:"varint,1,opt,name=kind,proto3" json:"kind,omitempty" form:"kind"`
	Subject   string `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject,omitempty" form:"subject"`
	Course    string `protobuf:"bytes,3,opt,name=course,proto3" json:"course,omitempty" form:"course"`
	Knowledge string `protobuf:"bytes,4,opt,name=knowledge,proto3" json:"knowledge,omitempty" form:"knowledge"`
	Page      int64  `protobuf:"varint,5,opt,name=page,proto3" json:"page,omitempty" form:"page"`
}

func (m *QueryQuestionReq) Reset()                    { *m = QueryQuestionReq{} }
func (m *QueryQuestionReq) String() string            { return proto.CompactTextString(m) }
func (*QueryQuestionReq) ProtoMessage()               {}
func (*QueryQuestionReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{4} }

func (m *QueryQuestionReq) GetKind() int64 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *QueryQuestionReq) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *QueryQuestionReq) GetCourse() string {
	if m != nil {
		return m.Course
	}
	return ""
}

func (m *QueryQuestionReq) GetKnowledge() string {
	if m != nil {
		return m.Knowledge
	}
	return ""
}

func (m *QueryQuestionReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type QueryQuestionReply struct {
	Questions   []*QuestionInfoReply `protobuf:"bytes,1,rep,name=questions" json:"questions,omitempty" form:"questions"`
	Currentpage int64                `protobuf:"varint,2,opt,name=currentpage,proto3" json:"currentpage,omitempty" form:"currentpage"`
	Totalpage   int64                `protobuf:"varint,3,opt,name=totalpage,proto3" json:"totalpage,omitempty" form:"totalpage"`
}

func (m *QueryQuestionReply) Reset()                    { *m = QueryQuestionReply{} }
func (m *QueryQuestionReply) String() string            { return proto.CompactTextString(m) }
func (*QueryQuestionReply) ProtoMessage()               {}
func (*QueryQuestionReply) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{5} }

func (m *QueryQuestionReply) GetQuestions() []*QuestionInfoReply {
	if m != nil {
		return m.Questions
	}
	return nil
}

func (m *QueryQuestionReply) GetCurrentpage() int64 {
	if m != nil {
		return m.Currentpage
	}
	return 0
}

func (m *QueryQuestionReply) GetTotalpage() int64 {
	if m != nil {
		return m.Totalpage
	}
	return 0
}

type CreateHomeWorkReq struct {
	Name      string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Classid   string   `protobuf:"bytes,2,opt,name=classid,proto3" json:"classid,omitempty" form:"classid"`
	Students  []string `protobuf:"bytes,3,rep,name=students" json:"students,omitempty" form:"students"`
	Questions []string `protobuf:"bytes,4,rep,name=questions" json:"questions,omitempty" form:"questions"`
}

func (m *CreateHomeWorkReq) Reset()                    { *m = CreateHomeWorkReq{} }
func (m *CreateHomeWorkReq) String() string            { return proto.CompactTextString(m) }
func (*CreateHomeWorkReq) ProtoMessage()               {}
func (*CreateHomeWorkReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{6} }

func (m *CreateHomeWorkReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateHomeWorkReq) GetClassid() string {
	if m != nil {
		return m.Classid
	}
	return ""
}

func (m *CreateHomeWorkReq) GetStudents() []string {
	if m != nil {
		return m.Students
	}
	return nil
}

func (m *CreateHomeWorkReq) GetQuestions() []string {
	if m != nil {
		return m.Questions
	}
	return nil
}

type CreateHomeWorkReply struct {
	Homeworkid string `protobuf:"bytes,1,opt,name=homeworkid,proto3" json:"homeworkid,omitempty" form:"homeworkid"`
}

func (m *CreateHomeWorkReply) Reset()                    { *m = CreateHomeWorkReply{} }
func (m *CreateHomeWorkReply) String() string            { return proto.CompactTextString(m) }
func (*CreateHomeWorkReply) ProtoMessage()               {}
func (*CreateHomeWorkReply) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{7} }

func (m *CreateHomeWorkReply) GetHomeworkid() string {
	if m != nil {
		return m.Homeworkid
	}
	return ""
}

type QueryMyHomeWorkReq struct {
	Userid  string `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty" form:"userid"`
	Classid string `protobuf:"bytes,2,opt,name=classid,proto3" json:"classid,omitempty" form:"classid"`
}

func (m *QueryMyHomeWorkReq) Reset()                    { *m = QueryMyHomeWorkReq{} }
func (m *QueryMyHomeWorkReq) String() string            { return proto.CompactTextString(m) }
func (*QueryMyHomeWorkReq) ProtoMessage()               {}
func (*QueryMyHomeWorkReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{8} }

func (m *QueryMyHomeWorkReq) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *QueryMyHomeWorkReq) GetClassid() string {
	if m != nil {
		return m.Classid
	}
	return ""
}

type QuestionInfo struct {
	Questionid string   `protobuf:"bytes,1,opt,name=questionid,proto3" json:"questionid,omitempty" form:"qustionid"`
	Kind       int64    `protobuf:"varint,2,opt,name=kind,proto3" json:"kind,omitempty" form:"kind"`
	Content    string   `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty" form:"content"`
	Qimage     bool     `protobuf:"varint,4,opt,name=qimage,proto3" json:"qimage,omitempty" form:"qimage"`
	Oimage     bool     `protobuf:"varint,5,opt,name=oimage,proto3" json:"oimage,omitempty" form:"oimage"`
	Option     []string `protobuf:"bytes,6,rep,name=option" json:"option,omitempty" form:"option"`
	Score      int64    `protobuf:"varint,7,opt,name=score,proto3" json:"score,omitempty" form:"socre"`
}

func (m *QuestionInfo) Reset()                    { *m = QuestionInfo{} }
func (m *QuestionInfo) String() string            { return proto.CompactTextString(m) }
func (*QuestionInfo) ProtoMessage()               {}
func (*QuestionInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{9} }

func (m *QuestionInfo) GetQuestionid() string {
	if m != nil {
		return m.Questionid
	}
	return ""
}

func (m *QuestionInfo) GetKind() int64 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *QuestionInfo) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *QuestionInfo) GetQimage() bool {
	if m != nil {
		return m.Qimage
	}
	return false
}

func (m *QuestionInfo) GetOimage() bool {
	if m != nil {
		return m.Oimage
	}
	return false
}

func (m *QuestionInfo) GetOption() []string {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *QuestionInfo) GetScore() int64 {
	if m != nil {
		return m.Score
	}
	return 0
}

type HomeWorkInfo struct {
	Homeworkid string          `protobuf:"bytes,1,opt,name=homeworkid,proto3" json:"homeworkid,omitempty" form:"homeworkid"`
	Name       string          `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Questions  []*QuestionInfo `protobuf:"bytes,3,rep,name=questions" json:"questions,omitempty" form:"questions"`
}

func (m *HomeWorkInfo) Reset()                    { *m = HomeWorkInfo{} }
func (m *HomeWorkInfo) String() string            { return proto.CompactTextString(m) }
func (*HomeWorkInfo) ProtoMessage()               {}
func (*HomeWorkInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{10} }

func (m *HomeWorkInfo) GetHomeworkid() string {
	if m != nil {
		return m.Homeworkid
	}
	return ""
}

func (m *HomeWorkInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HomeWorkInfo) GetQuestions() []*QuestionInfo {
	if m != nil {
		return m.Questions
	}
	return nil
}

type QueryMyHomeWorkReply struct {
	Homework []*HomeWorkInfo `protobuf:"bytes,1,rep,name=homework" json:"homework,omitempty" form:"homework"`
}

func (m *QueryMyHomeWorkReply) Reset()                    { *m = QueryMyHomeWorkReply{} }
func (m *QueryMyHomeWorkReply) String() string            { return proto.CompactTextString(m) }
func (*QueryMyHomeWorkReply) ProtoMessage()               {}
func (*QueryMyHomeWorkReply) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{11} }

func (m *QueryMyHomeWorkReply) GetHomework() []*HomeWorkInfo {
	if m != nil {
		return m.Homework
	}
	return nil
}

type DoQuestionInfo struct {
	Questionid string   `protobuf:"bytes,1,opt,name=questionid,proto3" json:"questionid,omitempty" form:"questionid"`
	Answer     []string `protobuf:"bytes,2,rep,name=answer" json:"answer,omitempty" form:"answer"`
	Aimage     bool     `protobuf:"varint,3,opt,name=aimage,proto3" json:"aimage,omitempty" form:"aimage"`
}

func (m *DoQuestionInfo) Reset()                    { *m = DoQuestionInfo{} }
func (m *DoQuestionInfo) String() string            { return proto.CompactTextString(m) }
func (*DoQuestionInfo) ProtoMessage()               {}
func (*DoQuestionInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{12} }

func (m *DoQuestionInfo) GetQuestionid() string {
	if m != nil {
		return m.Questionid
	}
	return ""
}

func (m *DoQuestionInfo) GetAnswer() []string {
	if m != nil {
		return m.Answer
	}
	return nil
}

func (m *DoQuestionInfo) GetAimage() bool {
	if m != nil {
		return m.Aimage
	}
	return false
}

type DoHomeWorkReq struct {
	Homeworkid string            `protobuf:"bytes,1,opt,name=homeworkid,proto3" json:"homeworkid,omitempty" form:"homeworkid"`
	Userid     string            `protobuf:"bytes,2,opt,name=userid,proto3" json:"userid,omitempty" form:"userid"`
	Username   string            `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty" form:"username"`
	Answer     []*DoQuestionInfo `protobuf:"bytes,4,rep,name=answer" json:"answer,omitempty" form:"answer"`
}

func (m *DoHomeWorkReq) Reset()                    { *m = DoHomeWorkReq{} }
func (m *DoHomeWorkReq) String() string            { return proto.CompactTextString(m) }
func (*DoHomeWorkReq) ProtoMessage()               {}
func (*DoHomeWorkReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{13} }

func (m *DoHomeWorkReq) GetHomeworkid() string {
	if m != nil {
		return m.Homeworkid
	}
	return ""
}

func (m *DoHomeWorkReq) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *DoHomeWorkReq) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *DoHomeWorkReq) GetAnswer() []*DoQuestionInfo {
	if m != nil {
		return m.Answer
	}
	return nil
}

type QueryAnswerRecordReq struct {
	Homeworkid string `protobuf:"bytes,1,opt,name=homeworkid,proto3" json:"homeworkid,omitempty" form:"homeworkid"`
}

func (m *QueryAnswerRecordReq) Reset()                    { *m = QueryAnswerRecordReq{} }
func (m *QueryAnswerRecordReq) String() string            { return proto.CompactTextString(m) }
func (*QueryAnswerRecordReq) ProtoMessage()               {}
func (*QueryAnswerRecordReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{14} }

func (m *QueryAnswerRecordReq) GetHomeworkid() string {
	if m != nil {
		return m.Homeworkid
	}
	return ""
}

type UserAnswerInfo struct {
	Username string   `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty" form:"username"`
	Userid   string   `protobuf:"bytes,2,opt,name=userid,proto3" json:"userid,omitempty" form:"userid"`
	Answer   []string `protobuf:"bytes,3,rep,name=answer" json:"answer,omitempty" form:"answer"`
}

func (m *UserAnswerInfo) Reset()                    { *m = UserAnswerInfo{} }
func (m *UserAnswerInfo) String() string            { return proto.CompactTextString(m) }
func (*UserAnswerInfo) ProtoMessage()               {}
func (*UserAnswerInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{15} }

func (m *UserAnswerInfo) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserAnswerInfo) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *UserAnswerInfo) GetAnswer() []string {
	if m != nil {
		return m.Answer
	}
	return nil
}

type AllUserAnswerInfo struct {
	Questionid    string            `protobuf:"bytes,1,opt,name=questionid,proto3" json:"questionid,omitempty" form:"questionid"`
	Content       string            `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty" form:"content"`
	Option        []string          `protobuf:"bytes,3,rep,name=option" json:"option,omitempty" form:"option"`
	Rightanswer   []string          `protobuf:"bytes,4,rep,name=rightanswer" json:"rightanswer,omitempty" form:"rightanswer"`
	Alluseranswer []*UserAnswerInfo `protobuf:"bytes,5,rep,name=alluseranswer" json:"alluseranswer,omitempty" form:"alluseranswer"`
}

func (m *AllUserAnswerInfo) Reset()                    { *m = AllUserAnswerInfo{} }
func (m *AllUserAnswerInfo) String() string            { return proto.CompactTextString(m) }
func (*AllUserAnswerInfo) ProtoMessage()               {}
func (*AllUserAnswerInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{16} }

func (m *AllUserAnswerInfo) GetQuestionid() string {
	if m != nil {
		return m.Questionid
	}
	return ""
}

func (m *AllUserAnswerInfo) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *AllUserAnswerInfo) GetOption() []string {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *AllUserAnswerInfo) GetRightanswer() []string {
	if m != nil {
		return m.Rightanswer
	}
	return nil
}

func (m *AllUserAnswerInfo) GetAlluseranswer() []*UserAnswerInfo {
	if m != nil {
		return m.Alluseranswer
	}
	return nil
}

type QueryAnswerRecordReply struct {
	Homeworkrecord []*AllUserAnswerInfo `protobuf:"bytes,1,rep,name=homeworkrecord" json:"homeworkrecord,omitempty" form:"homeworkrecord"`
}

func (m *QueryAnswerRecordReply) Reset()                    { *m = QueryAnswerRecordReply{} }
func (m *QueryAnswerRecordReply) String() string            { return proto.CompactTextString(m) }
func (*QueryAnswerRecordReply) ProtoMessage()               {}
func (*QueryAnswerRecordReply) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{17} }

func (m *QueryAnswerRecordReply) GetHomeworkrecord() []*AllUserAnswerInfo {
	if m != nil {
		return m.Homeworkrecord
	}
	return nil
}

type QueryHomeWorkInClassReply struct {
	Homework []*HomeWorkInfo `protobuf:"bytes,1,rep,name=homework" json:"homework,omitempty" form:"homeworkrecord"`
}

func (m *QueryHomeWorkInClassReply) Reset()         { *m = QueryHomeWorkInClassReply{} }
func (m *QueryHomeWorkInClassReply) String() string { return proto.CompactTextString(m) }
func (*QueryHomeWorkInClassReply) ProtoMessage()    {}
func (*QueryHomeWorkInClassReply) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{18}
}

func (m *QueryHomeWorkInClassReply) GetHomework() []*HomeWorkInfo {
	if m != nil {
		return m.Homework
	}
	return nil
}

type CreatePracticeSummaryReq struct {
	Name         string              `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Ownerid      string              `protobuf:"bytes,2,opt,name=ownerid,proto3" json:"ownerid,omitempty" form:"ownerid"`
	Classid      string              `protobuf:"bytes,3,opt,name=classid,proto3" json:"classid,omitempty" form:"classid"`
	Pstype       PracticeSummaryType `protobuf:"varint,4,opt,name=pstype,proto3,enum=api.PracticeSummaryType" json:"pstype,omitempty" form:"pstype"`
	Introduction string              `protobuf:"bytes,5,opt,name=introduction,proto3" json:"introduction,omitempty" form:"introduction"`
	Ownername    string              `protobuf:"bytes,6,opt,name=ownername,proto3" json:"ownername,omitempty" form:"ownername"`
}

func (m *CreatePracticeSummaryReq) Reset()         { *m = CreatePracticeSummaryReq{} }
func (m *CreatePracticeSummaryReq) String() string { return proto.CompactTextString(m) }
func (*CreatePracticeSummaryReq) ProtoMessage()    {}
func (*CreatePracticeSummaryReq) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{19}
}

func (m *CreatePracticeSummaryReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreatePracticeSummaryReq) GetOwnerid() string {
	if m != nil {
		return m.Ownerid
	}
	return ""
}

func (m *CreatePracticeSummaryReq) GetClassid() string {
	if m != nil {
		return m.Classid
	}
	return ""
}

func (m *CreatePracticeSummaryReq) GetPstype() PracticeSummaryType {
	if m != nil {
		return m.Pstype
	}
	return PracticeSummaryType_DEFAULT
}

func (m *CreatePracticeSummaryReq) GetIntroduction() string {
	if m != nil {
		return m.Introduction
	}
	return ""
}

func (m *CreatePracticeSummaryReq) GetOwnername() string {
	if m != nil {
		return m.Ownername
	}
	return ""
}

type CreatePracticeSummaryReply struct {
	Practicesummaryid string `protobuf:"bytes,1,opt,name=practicesummaryid,proto3" json:"practicesummaryid,omitempty" form:"practicesummaryid"`
}

func (m *CreatePracticeSummaryReply) Reset()         { *m = CreatePracticeSummaryReply{} }
func (m *CreatePracticeSummaryReply) String() string { return proto.CompactTextString(m) }
func (*CreatePracticeSummaryReply) ProtoMessage()    {}
func (*CreatePracticeSummaryReply) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{20}
}

func (m *CreatePracticeSummaryReply) GetPracticesummaryid() string {
	if m != nil {
		return m.Practicesummaryid
	}
	return ""
}

type QueryPracticeSummaryReq struct {
	Practicesummaryid string `protobuf:"bytes,1,opt,name=practicesummaryid,proto3" json:"practicesummaryid,omitempty" form:"practicesummaryid"`
	Page              int64  `protobuf:"varint,2,opt,name=page,proto3" json:"page,omitempty" form:"page"`
}

func (m *QueryPracticeSummaryReq) Reset()                    { *m = QueryPracticeSummaryReq{} }
func (m *QueryPracticeSummaryReq) String() string            { return proto.CompactTextString(m) }
func (*QueryPracticeSummaryReq) ProtoMessage()               {}
func (*QueryPracticeSummaryReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{21} }

func (m *QueryPracticeSummaryReq) GetPracticesummaryid() string {
	if m != nil {
		return m.Practicesummaryid
	}
	return ""
}

func (m *QueryPracticeSummaryReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type PracticeSummaryInfo struct {
	Practicesummaryid string              `protobuf:"bytes,1,opt,name=practicesummaryid,proto3" json:"practicesummaryid,omitempty" form:"practicesummaryid"`
	Name              string              `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Introduction      string              `protobuf:"bytes,3,opt,name=introduction,proto3" json:"introduction,omitempty" form:"introduction"`
	Questionnumbers   int64               `protobuf:"varint,4,opt,name=questionnumbers,proto3" json:"questionnumbers,omitempty" form:"questionnumbers"`
	Pstype            PracticeSummaryType `protobuf:"varint,5,opt,name=pstype,proto3,enum=api.PracticeSummaryType" json:"pstype,omitempty" form:"pstype"`
	Ownername         string              `protobuf:"bytes,6,opt,name=ownername,proto3" json:"ownername,omitempty" form:"ownername"`
	Coursename        string              `protobuf:"bytes,7,opt,name=coursename,proto3" json:"coursename,omitempty" form:"coursename"`
}

func (m *PracticeSummaryInfo) Reset()                    { *m = PracticeSummaryInfo{} }
func (m *PracticeSummaryInfo) String() string            { return proto.CompactTextString(m) }
func (*PracticeSummaryInfo) ProtoMessage()               {}
func (*PracticeSummaryInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{22} }

func (m *PracticeSummaryInfo) GetPracticesummaryid() string {
	if m != nil {
		return m.Practicesummaryid
	}
	return ""
}

func (m *PracticeSummaryInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PracticeSummaryInfo) GetIntroduction() string {
	if m != nil {
		return m.Introduction
	}
	return ""
}

func (m *PracticeSummaryInfo) GetQuestionnumbers() int64 {
	if m != nil {
		return m.Questionnumbers
	}
	return 0
}

func (m *PracticeSummaryInfo) GetPstype() PracticeSummaryType {
	if m != nil {
		return m.Pstype
	}
	return PracticeSummaryType_DEFAULT
}

func (m *PracticeSummaryInfo) GetOwnername() string {
	if m != nil {
		return m.Ownername
	}
	return ""
}

func (m *PracticeSummaryInfo) GetCoursename() string {
	if m != nil {
		return m.Coursename
	}
	return ""
}

type QuestionPre struct {
	Questionid    string `protobuf:"bytes,1,opt,name=questionid,proto3" json:"questionid,omitempty" form:"qustionid"`
	Kind          int64  `protobuf:"varint,2,opt,name=kind,proto3" json:"kind,omitempty" form:"kind"`
	Knowledgename string `protobuf:"bytes,3,opt,name=knowledgename,proto3" json:"knowledgename,omitempty" form:"knowledgename"`
	Name          string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Star          int64  `protobuf:"varint,5,opt,name=star,proto3" json:"star,omitempty" form:"star"`
}

func (m *QuestionPre) Reset()                    { *m = QuestionPre{} }
func (m *QuestionPre) String() string            { return proto.CompactTextString(m) }
func (*QuestionPre) ProtoMessage()               {}
func (*QuestionPre) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{23} }

func (m *QuestionPre) GetQuestionid() string {
	if m != nil {
		return m.Questionid
	}
	return ""
}

func (m *QuestionPre) GetKind() int64 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *QuestionPre) GetKnowledgename() string {
	if m != nil {
		return m.Knowledgename
	}
	return ""
}

func (m *QuestionPre) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QuestionPre) GetStar() int64 {
	if m != nil {
		return m.Star
	}
	return 0
}

type PracticeSummaryDetailInfo struct {
	Questions   []*QuestionPre `protobuf:"bytes,1,rep,name=questions" json:"questions,omitempty" form:"questions"`
	Currentpage int64          `protobuf:"varint,2,opt,name=currentpage,proto3" json:"currentpage,omitempty" form:"currentpage"`
	Totalpage   int64          `protobuf:"varint,3,opt,name=totalpage,proto3" json:"totalpage,omitempty" form:"totalpage"`
}

func (m *PracticeSummaryDetailInfo) Reset()         { *m = PracticeSummaryDetailInfo{} }
func (m *PracticeSummaryDetailInfo) String() string { return proto.CompactTextString(m) }
func (*PracticeSummaryDetailInfo) ProtoMessage()    {}
func (*PracticeSummaryDetailInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{24}
}

func (m *PracticeSummaryDetailInfo) GetQuestions() []*QuestionPre {
	if m != nil {
		return m.Questions
	}
	return nil
}

func (m *PracticeSummaryDetailInfo) GetCurrentpage() int64 {
	if m != nil {
		return m.Currentpage
	}
	return 0
}

func (m *PracticeSummaryDetailInfo) GetTotalpage() int64 {
	if m != nil {
		return m.Totalpage
	}
	return 0
}

type QueryMyPracticeSummaryReq struct {
	Userid string `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty" form:"userid"`
	Page   int64  `protobuf:"varint,2,opt,name=page,proto3" json:"page,omitempty" form:"page"`
}

func (m *QueryMyPracticeSummaryReq) Reset()         { *m = QueryMyPracticeSummaryReq{} }
func (m *QueryMyPracticeSummaryReq) String() string { return proto.CompactTextString(m) }
func (*QueryMyPracticeSummaryReq) ProtoMessage()    {}
func (*QueryMyPracticeSummaryReq) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{25}
}

func (m *QueryMyPracticeSummaryReq) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *QueryMyPracticeSummaryReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type QueryMyPracticeSummaryReply struct {
	Practicesummary []*PracticeSummaryInfo `protobuf:"bytes,1,rep,name=practicesummary" json:"practicesummary,omitempty" form:"practicesummary"`
	Currentpage     int64                  `protobuf:"varint,2,opt,name=currentpage,proto3" json:"currentpage,omitempty" form:"currentpage"`
	Totalpage       int64                  `protobuf:"varint,3,opt,name=totalpage,proto3" json:"totalpage,omitempty" form:"totalpage"`
}

func (m *QueryMyPracticeSummaryReply) Reset()         { *m = QueryMyPracticeSummaryReply{} }
func (m *QueryMyPracticeSummaryReply) String() string { return proto.CompactTextString(m) }
func (*QueryMyPracticeSummaryReply) ProtoMessage()    {}
func (*QueryMyPracticeSummaryReply) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{26}
}

func (m *QueryMyPracticeSummaryReply) GetPracticesummary() []*PracticeSummaryInfo {
	if m != nil {
		return m.Practicesummary
	}
	return nil
}

func (m *QueryMyPracticeSummaryReply) GetCurrentpage() int64 {
	if m != nil {
		return m.Currentpage
	}
	return 0
}

func (m *QueryMyPracticeSummaryReply) GetTotalpage() int64 {
	if m != nil {
		return m.Totalpage
	}
	return 0
}

type ControllQuestionInPSReq struct {
	Practicesummaryid string   `protobuf:"bytes,1,opt,name=practicesummaryid,proto3" json:"practicesummaryid,omitempty" form:"practicesummaryid"`
	Questions         []string `protobuf:"bytes,2,rep,name=questions" json:"questions,omitempty" form:"questions"`
}

func (m *ControllQuestionInPSReq) Reset()                    { *m = ControllQuestionInPSReq{} }
func (m *ControllQuestionInPSReq) String() string            { return proto.CompactTextString(m) }
func (*ControllQuestionInPSReq) ProtoMessage()               {}
func (*ControllQuestionInPSReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{27} }

func (m *ControllQuestionInPSReq) GetPracticesummaryid() string {
	if m != nil {
		return m.Practicesummaryid
	}
	return ""
}

func (m *ControllQuestionInPSReq) GetQuestions() []string {
	if m != nil {
		return m.Questions
	}
	return nil
}

type CreatePaperReq struct {
	Name           string                             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Classid        string                             `protobuf:"bytes,2,opt,name=classid,proto3" json:"classid,omitempty" form:"classid"`
	Questions      []*CreatePaperReq_QuestionsInPaper `protobuf:"bytes,4,rep,name=questions" json:"questions,omitempty" form:"questions"`
	Continuingtime int64                              `protobuf:"varint,5,opt,name=continuingtime,proto3" json:"continuingtime,omitempty" form:"continuingtime"`
}

func (m *CreatePaperReq) Reset()                    { *m = CreatePaperReq{} }
func (m *CreatePaperReq) String() string            { return proto.CompactTextString(m) }
func (*CreatePaperReq) ProtoMessage()               {}
func (*CreatePaperReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{28} }

func (m *CreatePaperReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreatePaperReq) GetClassid() string {
	if m != nil {
		return m.Classid
	}
	return ""
}

func (m *CreatePaperReq) GetQuestions() []*CreatePaperReq_QuestionsInPaper {
	if m != nil {
		return m.Questions
	}
	return nil
}

func (m *CreatePaperReq) GetContinuingtime() int64 {
	if m != nil {
		return m.Continuingtime
	}
	return 0
}

type CreatePaperReq_QuestionsInPaper struct {
	Questionid string `protobuf:"bytes,1,opt,name=questionid,proto3" json:"questionid,omitempty" form:"questionid"`
	Score      int64  `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty" form:"score"`
	Needcheck  bool   `protobuf:"varint,3,opt,name=needcheck,proto3" json:"needcheck,omitempty" form:"needcheck"`
}

func (m *CreatePaperReq_QuestionsInPaper) Reset()         { *m = CreatePaperReq_QuestionsInPaper{} }
func (m *CreatePaperReq_QuestionsInPaper) String() string { return proto.CompactTextString(m) }
func (*CreatePaperReq_QuestionsInPaper) ProtoMessage()    {}
func (*CreatePaperReq_QuestionsInPaper) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{28, 0}
}

func (m *CreatePaperReq_QuestionsInPaper) GetQuestionid() string {
	if m != nil {
		return m.Questionid
	}
	return ""
}

func (m *CreatePaperReq_QuestionsInPaper) GetScore() int64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *CreatePaperReq_QuestionsInPaper) GetNeedcheck() bool {
	if m != nil {
		return m.Needcheck
	}
	return false
}

type CreatePaperReply struct {
	Paperid string `protobuf:"bytes,1,opt,name=paperid,proto3" json:"paperid,omitempty" form:"paperid"`
}

func (m *CreatePaperReply) Reset()                    { *m = CreatePaperReply{} }
func (m *CreatePaperReply) String() string            { return proto.CompactTextString(m) }
func (*CreatePaperReply) ProtoMessage()               {}
func (*CreatePaperReply) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{29} }

func (m *CreatePaperReply) GetPaperid() string {
	if m != nil {
		return m.Paperid
	}
	return ""
}

type QueryPaperInClassReq struct {
	Userid  string `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty" form:"userid"`
	Classid string `protobuf:"bytes,2,opt,name=classid,proto3" json:"classid,omitempty" form:"classid"`
	Page    int64  `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty" form:"page"`
}

func (m *QueryPaperInClassReq) Reset()                    { *m = QueryPaperInClassReq{} }
func (m *QueryPaperInClassReq) String() string            { return proto.CompactTextString(m) }
func (*QueryPaperInClassReq) ProtoMessage()               {}
func (*QueryPaperInClassReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{30} }

func (m *QueryPaperInClassReq) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *QueryPaperInClassReq) GetClassid() string {
	if m != nil {
		return m.Classid
	}
	return ""
}

func (m *QueryPaperInClassReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type QueryPaperInClassReply struct {
	Paper       []*PaperInfo `protobuf:"bytes,1,rep,name=paper" json:"paper,omitempty" form:"paper"`
	Currentpage int64        `protobuf:"varint,2,opt,name=currentpage,proto3" json:"currentpage,omitempty" form:"currentpage"`
	Totalpage   int64        `protobuf:"varint,3,opt,name=totalpage,proto3" json:"totalpage,omitempty" form:"totalpage"`
}

func (m *QueryPaperInClassReply) Reset()                    { *m = QueryPaperInClassReply{} }
func (m *QueryPaperInClassReply) String() string            { return proto.CompactTextString(m) }
func (*QueryPaperInClassReply) ProtoMessage()               {}
func (*QueryPaperInClassReply) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{31} }

func (m *QueryPaperInClassReply) GetPaper() []*PaperInfo {
	if m != nil {
		return m.Paper
	}
	return nil
}

func (m *QueryPaperInClassReply) GetCurrentpage() int64 {
	if m != nil {
		return m.Currentpage
	}
	return 0
}

func (m *QueryPaperInClassReply) GetTotalpage() int64 {
	if m != nil {
		return m.Totalpage
	}
	return 0
}

type QueryPaperQuestionsReq struct {
	Paperid string `protobuf:"bytes,1,opt,name=paperid,proto3" json:"paperid,omitempty" form:"paperid"`
}

func (m *QueryPaperQuestionsReq) Reset()                    { *m = QueryPaperQuestionsReq{} }
func (m *QueryPaperQuestionsReq) String() string            { return proto.CompactTextString(m) }
func (*QueryPaperQuestionsReq) ProtoMessage()               {}
func (*QueryPaperQuestionsReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{32} }

func (m *QueryPaperQuestionsReq) GetPaperid() string {
	if m != nil {
		return m.Paperid
	}
	return ""
}

type QueryPaperQuestionsReply struct {
	Paper          []*QuestionInfo `protobuf:"bytes,1,rep,name=paper" json:"paper,omitempty" form:"paper"`
	Name           string          `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Totalscore     int64           `protobuf:"varint,3,opt,name=totalscore,proto3" json:"totalscore,omitempty" form:"totalscore"`
	Continuingtime int64           `protobuf:"varint,4,opt,name=continuingtime,proto3" json:"continuingtime,omitempty" form:"continuingtime"`
}

func (m *QueryPaperQuestionsReply) Reset()         { *m = QueryPaperQuestionsReply{} }
func (m *QueryPaperQuestionsReply) String() string { return proto.CompactTextString(m) }
func (*QueryPaperQuestionsReply) ProtoMessage()    {}
func (*QueryPaperQuestionsReply) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{33}
}

func (m *QueryPaperQuestionsReply) GetPaper() []*QuestionInfo {
	if m != nil {
		return m.Paper
	}
	return nil
}

func (m *QueryPaperQuestionsReply) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryPaperQuestionsReply) GetTotalscore() int64 {
	if m != nil {
		return m.Totalscore
	}
	return 0
}

func (m *QueryPaperQuestionsReply) GetContinuingtime() int64 {
	if m != nil {
		return m.Continuingtime
	}
	return 0
}

type PaperInfo struct {
	Paperid    string `protobuf:"bytes,1,opt,name=paperid,proto3" json:"paperid,omitempty" form:"paperid"`
	Name       string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Totalscore int64  `protobuf:"varint,3,opt,name=totalscore,proto3" json:"totalscore,omitempty" form:"totalscore"`
	// repeated QuestionInfo questions = 4 [(gogoproto.moretags) = "form:\"questions\""] ;
	Continuingtime int64 `protobuf:"varint,4,opt,name=continuingtime,proto3" json:"continuingtime,omitempty" form:"continuingtime"`
}

func (m *PaperInfo) Reset()                    { *m = PaperInfo{} }
func (m *PaperInfo) String() string            { return proto.CompactTextString(m) }
func (*PaperInfo) ProtoMessage()               {}
func (*PaperInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{34} }

func (m *PaperInfo) GetPaperid() string {
	if m != nil {
		return m.Paperid
	}
	return ""
}

func (m *PaperInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PaperInfo) GetTotalscore() int64 {
	if m != nil {
		return m.Totalscore
	}
	return 0
}

func (m *PaperInfo) GetContinuingtime() int64 {
	if m != nil {
		return m.Continuingtime
	}
	return 0
}

type DoPaperReq struct {
	Paperid  string            `protobuf:"bytes,1,opt,name=paperid,proto3" json:"paperid,omitempty" form:"paperid"`
	Userid   string            `protobuf:"bytes,2,opt,name=userid,proto3" json:"userid,omitempty" form:"userid"`
	Username string            `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty" form:"username"`
	Answer   []*DoQuestionInfo `protobuf:"bytes,4,rep,name=answer" json:"answer,omitempty" form:"answer"`
}

func (m *DoPaperReq) Reset()                    { *m = DoPaperReq{} }
func (m *DoPaperReq) String() string            { return proto.CompactTextString(m) }
func (*DoPaperReq) ProtoMessage()               {}
func (*DoPaperReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{35} }

func (m *DoPaperReq) GetPaperid() string {
	if m != nil {
		return m.Paperid
	}
	return ""
}

func (m *DoPaperReq) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *DoPaperReq) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *DoPaperReq) GetAnswer() []*DoQuestionInfo {
	if m != nil {
		return m.Answer
	}
	return nil
}

type QueryPaperAnswerRecordReq struct {
	Paperid string `protobuf:"bytes,1,opt,name=paperid,proto3" json:"paperid,omitempty" form:"paperid"`
	Userid  string `protobuf:"bytes,2,opt,name=userid,proto3" json:"userid,omitempty" form:"userid"`
}

func (m *QueryPaperAnswerRecordReq) Reset()         { *m = QueryPaperAnswerRecordReq{} }
func (m *QueryPaperAnswerRecordReq) String() string { return proto.CompactTextString(m) }
func (*QueryPaperAnswerRecordReq) ProtoMessage()    {}
func (*QueryPaperAnswerRecordReq) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{36}
}

func (m *QueryPaperAnswerRecordReq) GetPaperid() string {
	if m != nil {
		return m.Paperid
	}
	return ""
}

func (m *QueryPaperAnswerRecordReq) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

type QueryPaperAnswerRecordReply struct {
	Paperid     string                 `protobuf:"bytes,1,opt,name=paperid,proto3" json:"paperid,omitempty" form:"paperid"`
	Papername   string                 `protobuf:"bytes,2,opt,name=papername,proto3" json:"papername,omitempty" form:"papername"`
	Totalscore  int64                  `protobuf:"varint,3,opt,name=totalscore,proto3" json:"totalscore,omitempty" form:"totalscore"`
	Getscore    int64                  `protobuf:"varint,4,opt,name=getscore,proto3" json:"getscore,omitempty" form:"getscore"`
	Needcheck   bool                   `protobuf:"varint,5,opt,name=needcheck,proto3" json:"needcheck,omitempty" form:"needcheck"`
	Paperrecord []*UserPaperAnswerInfo `protobuf:"bytes,6,rep,name=paperrecord" json:"paperrecord,omitempty" form:"homeworkrecord"`
}

func (m *QueryPaperAnswerRecordReply) Reset()         { *m = QueryPaperAnswerRecordReply{} }
func (m *QueryPaperAnswerRecordReply) String() string { return proto.CompactTextString(m) }
func (*QueryPaperAnswerRecordReply) ProtoMessage()    {}
func (*QueryPaperAnswerRecordReply) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{37}
}

func (m *QueryPaperAnswerRecordReply) GetPaperid() string {
	if m != nil {
		return m.Paperid
	}
	return ""
}

func (m *QueryPaperAnswerRecordReply) GetPapername() string {
	if m != nil {
		return m.Papername
	}
	return ""
}

func (m *QueryPaperAnswerRecordReply) GetTotalscore() int64 {
	if m != nil {
		return m.Totalscore
	}
	return 0
}

func (m *QueryPaperAnswerRecordReply) GetGetscore() int64 {
	if m != nil {
		return m.Getscore
	}
	return 0
}

func (m *QueryPaperAnswerRecordReply) GetNeedcheck() bool {
	if m != nil {
		return m.Needcheck
	}
	return false
}

func (m *QueryPaperAnswerRecordReply) GetPaperrecord() []*UserPaperAnswerInfo {
	if m != nil {
		return m.Paperrecord
	}
	return nil
}

type UserPaperAnswerInfo struct {
	Questionid  string   `protobuf:"bytes,1,opt,name=questionid,proto3" json:"questionid,omitempty" form:"questionid"`
	Kind        int64    `protobuf:"varint,2,opt,name=kind,proto3" json:"kind,omitempty" form:"kind"`
	Name        string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Content     string   `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty" form:"content"`
	Qimage      bool     `protobuf:"varint,5,opt,name=qimage,proto3" json:"qimage,omitempty" form:"qimage"`
	Option      []string `protobuf:"bytes,6,rep,name=option" json:"option,omitempty" form:"option"`
	Oimage      bool     `protobuf:"varint,7,opt,name=oimage,proto3" json:"oimage,omitempty" form:"oimage"`
	Rightanswer []string `protobuf:"bytes,8,rep,name=rightanswer" json:"rightanswer,omitempty" form:"rightanswer"`
	Raimage     bool     `protobuf:"varint,9,opt,name=raimage,proto3" json:"raimage,omitempty" form:"raimage"`
	Useranswer  []string `protobuf:"bytes,10,rep,name=useranswer" json:"useranswer,omitempty" form:"useranswer"`
	Uaimage     bool     `protobuf:"varint,11,opt,name=uaimage,proto3" json:"uaimage,omitempty" form:"uaimage"`
	Needcheck   bool     `protobuf:"varint,12,opt,name=needcheck,proto3" json:"needcheck,omitempty" form:"needcheck"`
	Explain     string   `protobuf:"bytes,13,opt,name=explain,proto3" json:"explain,omitempty" form:"explain"`
	Star        int64    `protobuf:"varint,14,opt,name=star,proto3" json:"star,omitempty" form:"star"`
}

func (m *UserPaperAnswerInfo) Reset()                    { *m = UserPaperAnswerInfo{} }
func (m *UserPaperAnswerInfo) String() string            { return proto.CompactTextString(m) }
func (*UserPaperAnswerInfo) ProtoMessage()               {}
func (*UserPaperAnswerInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{38} }

func (m *UserPaperAnswerInfo) GetQuestionid() string {
	if m != nil {
		return m.Questionid
	}
	return ""
}

func (m *UserPaperAnswerInfo) GetKind() int64 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *UserPaperAnswerInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UserPaperAnswerInfo) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *UserPaperAnswerInfo) GetQimage() bool {
	if m != nil {
		return m.Qimage
	}
	return false
}

func (m *UserPaperAnswerInfo) GetOption() []string {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *UserPaperAnswerInfo) GetOimage() bool {
	if m != nil {
		return m.Oimage
	}
	return false
}

func (m *UserPaperAnswerInfo) GetRightanswer() []string {
	if m != nil {
		return m.Rightanswer
	}
	return nil
}

func (m *UserPaperAnswerInfo) GetRaimage() bool {
	if m != nil {
		return m.Raimage
	}
	return false
}

func (m *UserPaperAnswerInfo) GetUseranswer() []string {
	if m != nil {
		return m.Useranswer
	}
	return nil
}

func (m *UserPaperAnswerInfo) GetUaimage() bool {
	if m != nil {
		return m.Uaimage
	}
	return false
}

func (m *UserPaperAnswerInfo) GetNeedcheck() bool {
	if m != nil {
		return m.Needcheck
	}
	return false
}

func (m *UserPaperAnswerInfo) GetExplain() string {
	if m != nil {
		return m.Explain
	}
	return ""
}

func (m *UserPaperAnswerInfo) GetStar() int64 {
	if m != nil {
		return m.Star
	}
	return 0
}

func init() {
	proto.RegisterType((*CRqQueryMyQuestionInfoBySubject)(nil), "api.CRqQueryMyQuestionInfoBySubject")
	proto.RegisterType((*CRpMyQuestionInfoBySubject)(nil), "api.CRpMyQuestionInfoBySubject")
	proto.RegisterType((*CreateQuestionReq)(nil), "api.CreateQuestionReq")
	proto.RegisterType((*QuestionInfoReply)(nil), "api.QuestionInfoReply")
	proto.RegisterType((*QueryQuestionReq)(nil), "api.QueryQuestionReq")
	proto.RegisterType((*QueryQuestionReply)(nil), "api.QueryQuestionReply")
	proto.RegisterType((*CreateHomeWorkReq)(nil), "api.CreateHomeWorkReq")
	proto.RegisterType((*CreateHomeWorkReply)(nil), "api.CreateHomeWorkReply")
	proto.RegisterType((*QueryMyHomeWorkReq)(nil), "api.QueryMyHomeWorkReq")
	proto.RegisterType((*QuestionInfo)(nil), "api.QuestionInfo")
	proto.RegisterType((*HomeWorkInfo)(nil), "api.HomeWorkInfo")
	proto.RegisterType((*QueryMyHomeWorkReply)(nil), "api.QueryMyHomeWorkReply")
	proto.RegisterType((*DoQuestionInfo)(nil), "api.DoQuestionInfo")
	proto.RegisterType((*DoHomeWorkReq)(nil), "api.DoHomeWorkReq")
	proto.RegisterType((*QueryAnswerRecordReq)(nil), "api.QueryAnswerRecordReq")
	proto.RegisterType((*UserAnswerInfo)(nil), "api.UserAnswerInfo")
	proto.RegisterType((*AllUserAnswerInfo)(nil), "api.AllUserAnswerInfo")
	proto.RegisterType((*QueryAnswerRecordReply)(nil), "api.QueryAnswerRecordReply")
	proto.RegisterType((*QueryHomeWorkInClassReply)(nil), "api.QueryHomeWorkInClassReply")
	proto.RegisterType((*CreatePracticeSummaryReq)(nil), "api.CreatePracticeSummaryReq")
	proto.RegisterType((*CreatePracticeSummaryReply)(nil), "api.CreatePracticeSummaryReply")
	proto.RegisterType((*QueryPracticeSummaryReq)(nil), "api.QueryPracticeSummaryReq")
	proto.RegisterType((*PracticeSummaryInfo)(nil), "api.PracticeSummaryInfo")
	proto.RegisterType((*QuestionPre)(nil), "api.QuestionPre")
	proto.RegisterType((*PracticeSummaryDetailInfo)(nil), "api.PracticeSummaryDetailInfo")
	proto.RegisterType((*QueryMyPracticeSummaryReq)(nil), "api.QueryMyPracticeSummaryReq")
	proto.RegisterType((*QueryMyPracticeSummaryReply)(nil), "api.QueryMyPracticeSummaryReply")
	proto.RegisterType((*ControllQuestionInPSReq)(nil), "api.ControllQuestionInPSReq")
	proto.RegisterType((*CreatePaperReq)(nil), "api.CreatePaperReq")
	proto.RegisterType((*CreatePaperReq_QuestionsInPaper)(nil), "api.CreatePaperReq.QuestionsInPaper")
	proto.RegisterType((*CreatePaperReply)(nil), "api.CreatePaperReply")
	proto.RegisterType((*QueryPaperInClassReq)(nil), "api.QueryPaperInClassReq")
	proto.RegisterType((*QueryPaperInClassReply)(nil), "api.QueryPaperInClassReply")
	proto.RegisterType((*QueryPaperQuestionsReq)(nil), "api.QueryPaperQuestionsReq")
	proto.RegisterType((*QueryPaperQuestionsReply)(nil), "api.QueryPaperQuestionsReply")
	proto.RegisterType((*PaperInfo)(nil), "api.PaperInfo")
	proto.RegisterType((*DoPaperReq)(nil), "api.DoPaperReq")
	proto.RegisterType((*QueryPaperAnswerRecordReq)(nil), "api.QueryPaperAnswerRecordReq")
	proto.RegisterType((*QueryPaperAnswerRecordReply)(nil), "api.QueryPaperAnswerRecordReply")
	proto.RegisterType((*UserPaperAnswerInfo)(nil), "api.UserPaperAnswerInfo")
	proto.RegisterEnum("api.PracticeSummaryType", PracticeSummaryType_name, PracticeSummaryType_value)
}
func (m *CRqQueryMyQuestionInfoBySubject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CRqQueryMyQuestionInfoBySubject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if len(m.Subject) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Subject)))
		i += copy(dAtA[i:], m.Subject)
	}
	if m.Endtime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Endtime))
	}
	return i, nil
}

func (m *CRpMyQuestionInfoBySubject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CRpMyQuestionInfoBySubject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Knowledgenodes) > 0 {
		for _, s := range m.Knowledgenodes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CreateQuestionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateQuestionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Kind))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Qimage {
		dAtA[i] = 0x20
		i++
		if m.Qimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Oimage {
		dAtA[i] = 0x30
		i++
		if m.Oimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Aimage {
		dAtA[i] = 0x40
		i++
		if m.Aimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Subject) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Subject)))
		i += copy(dAtA[i:], m.Subject)
	}
	if len(m.Course) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Course)))
		i += copy(dAtA[i:], m.Course)
	}
	if len(m.Knowledge) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Knowledge)))
		i += copy(dAtA[i:], m.Knowledge)
	}
	if m.Needcheck {
		dAtA[i] = 0x60
		i++
		if m.Needcheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Explain) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Explain)))
		i += copy(dAtA[i:], m.Explain)
	}
	if m.Star != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Star))
	}
	return i, nil
}

func (m *QuestionInfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuestionInfoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Kind))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Qimage {
		dAtA[i] = 0x20
		i++
		if m.Qimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Oimage {
		dAtA[i] = 0x30
		i++
		if m.Oimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Aimage {
		dAtA[i] = 0x40
		i++
		if m.Aimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Subject) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Subject)))
		i += copy(dAtA[i:], m.Subject)
	}
	if len(m.Course) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Course)))
		i += copy(dAtA[i:], m.Course)
	}
	if len(m.Knowledge) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Knowledge)))
		i += copy(dAtA[i:], m.Knowledge)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Needcheck {
		dAtA[i] = 0x68
		i++
		if m.Needcheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Explain) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Explain)))
		i += copy(dAtA[i:], m.Explain)
	}
	if m.Star != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Star))
	}
	return i, nil
}

func (m *QueryQuestionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryQuestionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Kind))
	}
	if len(m.Subject) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Subject)))
		i += copy(dAtA[i:], m.Subject)
	}
	if len(m.Course) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Course)))
		i += copy(dAtA[i:], m.Course)
	}
	if len(m.Knowledge) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Knowledge)))
		i += copy(dAtA[i:], m.Knowledge)
	}
	if m.Page != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *QueryQuestionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryQuestionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questions) > 0 {
		for _, msg := range m.Questions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Currentpage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Currentpage))
	}
	if m.Totalpage != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Totalpage))
	}
	return i, nil
}

func (m *CreateHomeWorkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateHomeWorkReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Classid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Classid)))
		i += copy(dAtA[i:], m.Classid)
	}
	if len(m.Students) > 0 {
		for _, s := range m.Students {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Questions) > 0 {
		for _, s := range m.Questions {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CreateHomeWorkReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateHomeWorkReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homeworkid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Homeworkid)))
		i += copy(dAtA[i:], m.Homeworkid)
	}
	return i, nil
}

func (m *QueryMyHomeWorkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMyHomeWorkReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Classid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Classid)))
		i += copy(dAtA[i:], m.Classid)
	}
	return i, nil
}

func (m *QuestionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuestionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questionid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Questionid)))
		i += copy(dAtA[i:], m.Questionid)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Kind))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Qimage {
		dAtA[i] = 0x20
		i++
		if m.Qimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Oimage {
		dAtA[i] = 0x28
		i++
		if m.Oimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Score != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *HomeWorkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HomeWorkInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homeworkid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Homeworkid)))
		i += copy(dAtA[i:], m.Homeworkid)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Questions) > 0 {
		for _, msg := range m.Questions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryMyHomeWorkReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMyHomeWorkReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homework) > 0 {
		for _, msg := range m.Homework {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoQuestionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoQuestionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questionid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Questionid)))
		i += copy(dAtA[i:], m.Questionid)
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Aimage {
		dAtA[i] = 0x18
		i++
		if m.Aimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DoHomeWorkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoHomeWorkReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homeworkid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Homeworkid)))
		i += copy(dAtA[i:], m.Homeworkid)
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Answer) > 0 {
		for _, msg := range m.Answer {
			dAtA[i] = 0x22
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryAnswerRecordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnswerRecordReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homeworkid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Homeworkid)))
		i += copy(dAtA[i:], m.Homeworkid)
	}
	return i, nil
}

func (m *UserAnswerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAnswerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AllUserAnswerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllUserAnswerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questionid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Questionid)))
		i += copy(dAtA[i:], m.Questionid)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Rightanswer) > 0 {
		for _, s := range m.Rightanswer {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Alluseranswer) > 0 {
		for _, msg := range m.Alluseranswer {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryAnswerRecordReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnswerRecordReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homeworkrecord) > 0 {
		for _, msg := range m.Homeworkrecord {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryHomeWorkInClassReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryHomeWorkInClassReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homework) > 0 {
		for _, msg := range m.Homework {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreatePracticeSummaryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePracticeSummaryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Ownerid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Ownerid)))
		i += copy(dAtA[i:], m.Ownerid)
	}
	if len(m.Classid) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Classid)))
		i += copy(dAtA[i:], m.Classid)
	}
	if m.Pstype != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Pstype))
	}
	if len(m.Introduction) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Introduction)))
		i += copy(dAtA[i:], m.Introduction)
	}
	if len(m.Ownername) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Ownername)))
		i += copy(dAtA[i:], m.Ownername)
	}
	return i, nil
}

func (m *CreatePracticeSummaryReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePracticeSummaryReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Practicesummaryid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Practicesummaryid)))
		i += copy(dAtA[i:], m.Practicesummaryid)
	}
	return i, nil
}

func (m *QueryPracticeSummaryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPracticeSummaryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Practicesummaryid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Practicesummaryid)))
		i += copy(dAtA[i:], m.Practicesummaryid)
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *PracticeSummaryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PracticeSummaryInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Practicesummaryid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Practicesummaryid)))
		i += copy(dAtA[i:], m.Practicesummaryid)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Introduction) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Introduction)))
		i += copy(dAtA[i:], m.Introduction)
	}
	if m.Questionnumbers != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Questionnumbers))
	}
	if m.Pstype != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Pstype))
	}
	if len(m.Ownername) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Ownername)))
		i += copy(dAtA[i:], m.Ownername)
	}
	if len(m.Coursename) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Coursename)))
		i += copy(dAtA[i:], m.Coursename)
	}
	return i, nil
}

func (m *QuestionPre) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuestionPre) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questionid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Questionid)))
		i += copy(dAtA[i:], m.Questionid)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Kind))
	}
	if len(m.Knowledgename) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Knowledgename)))
		i += copy(dAtA[i:], m.Knowledgename)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Star != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Star))
	}
	return i, nil
}

func (m *PracticeSummaryDetailInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PracticeSummaryDetailInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questions) > 0 {
		for _, msg := range m.Questions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Currentpage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Currentpage))
	}
	if m.Totalpage != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Totalpage))
	}
	return i, nil
}

func (m *QueryMyPracticeSummaryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMyPracticeSummaryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *QueryMyPracticeSummaryReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMyPracticeSummaryReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Practicesummary) > 0 {
		for _, msg := range m.Practicesummary {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Currentpage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Currentpage))
	}
	if m.Totalpage != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Totalpage))
	}
	return i, nil
}

func (m *ControllQuestionInPSReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllQuestionInPSReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Practicesummaryid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Practicesummaryid)))
		i += copy(dAtA[i:], m.Practicesummaryid)
	}
	if len(m.Questions) > 0 {
		for _, s := range m.Questions {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CreatePaperReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePaperReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Classid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Classid)))
		i += copy(dAtA[i:], m.Classid)
	}
	if len(m.Questions) > 0 {
		for _, msg := range m.Questions {
			dAtA[i] = 0x22
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Continuingtime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Continuingtime))
	}
	return i, nil
}

func (m *CreatePaperReq_QuestionsInPaper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePaperReq_QuestionsInPaper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questionid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Questionid)))
		i += copy(dAtA[i:], m.Questionid)
	}
	if m.Score != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Score))
	}
	if m.Needcheck {
		dAtA[i] = 0x18
		i++
		if m.Needcheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CreatePaperReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePaperReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Paperid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Paperid)))
		i += copy(dAtA[i:], m.Paperid)
	}
	return i, nil
}

func (m *QueryPaperInClassReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPaperInClassReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Classid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Classid)))
		i += copy(dAtA[i:], m.Classid)
	}
	if m.Page != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *QueryPaperInClassReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPaperInClassReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Paper) > 0 {
		for _, msg := range m.Paper {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Currentpage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Currentpage))
	}
	if m.Totalpage != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Totalpage))
	}
	return i, nil
}

func (m *QueryPaperQuestionsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPaperQuestionsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Paperid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Paperid)))
		i += copy(dAtA[i:], m.Paperid)
	}
	return i, nil
}

func (m *QueryPaperQuestionsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPaperQuestionsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Paper) > 0 {
		for _, msg := range m.Paper {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Totalscore != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Totalscore))
	}
	if m.Continuingtime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Continuingtime))
	}
	return i, nil
}

func (m *PaperInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaperInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Paperid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Paperid)))
		i += copy(dAtA[i:], m.Paperid)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Totalscore != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Totalscore))
	}
	if m.Continuingtime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Continuingtime))
	}
	return i, nil
}

func (m *DoPaperReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoPaperReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Paperid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Paperid)))
		i += copy(dAtA[i:], m.Paperid)
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Answer) > 0 {
		for _, msg := range m.Answer {
			dAtA[i] = 0x22
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryPaperAnswerRecordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPaperAnswerRecordReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Paperid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Paperid)))
		i += copy(dAtA[i:], m.Paperid)
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	return i, nil
}

func (m *QueryPaperAnswerRecordReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPaperAnswerRecordReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Paperid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Paperid)))
		i += copy(dAtA[i:], m.Paperid)
	}
	if len(m.Papername) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Papername)))
		i += copy(dAtA[i:], m.Papername)
	}
	if m.Totalscore != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Totalscore))
	}
	if m.Getscore != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Getscore))
	}
	if m.Needcheck {
		dAtA[i] = 0x28
		i++
		if m.Needcheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Paperrecord) > 0 {
		for _, msg := range m.Paperrecord {
			dAtA[i] = 0x32
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UserPaperAnswerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPaperAnswerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questionid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Questionid)))
		i += copy(dAtA[i:], m.Questionid)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Kind))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Qimage {
		dAtA[i] = 0x28
		i++
		if m.Qimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Oimage {
		dAtA[i] = 0x38
		i++
		if m.Oimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Rightanswer) > 0 {
		for _, s := range m.Rightanswer {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Raimage {
		dAtA[i] = 0x48
		i++
		if m.Raimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Useranswer) > 0 {
		for _, s := range m.Useranswer {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Uaimage {
		dAtA[i] = 0x58
		i++
		if m.Uaimage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Needcheck {
		dAtA[i] = 0x60
		i++
		if m.Needcheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Explain) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Explain)))
		i += copy(dAtA[i:], m.Explain)
	}
	if m.Star != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Star))
	}
	return i, nil
}

func encodeVarintQuestion(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CRqQueryMyQuestionInfoBySubject) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Endtime != 0 {
		n += 1 + sovQuestion(uint64(m.Endtime))
	}
	return n
}

func (m *CRpMyQuestionInfoBySubject) Size() (n int) {
	var l int
	_ = l
	if len(m.Knowledgenodes) > 0 {
		for _, s := range m.Knowledgenodes {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *CreateQuestionReq) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovQuestion(uint64(m.Kind))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Qimage {
		n += 2
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Oimage {
		n += 2
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Aimage {
		n += 2
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Course)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Knowledge)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Needcheck {
		n += 2
	}
	l = len(m.Explain)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Star != 0 {
		n += 1 + sovQuestion(uint64(m.Star))
	}
	return n
}

func (m *QuestionInfoReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovQuestion(uint64(m.Kind))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Qimage {
		n += 2
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Oimage {
		n += 2
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Aimage {
		n += 2
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Course)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Knowledge)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Needcheck {
		n += 2
	}
	l = len(m.Explain)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Star != 0 {
		n += 1 + sovQuestion(uint64(m.Star))
	}
	return n
}

func (m *QueryQuestionReq) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovQuestion(uint64(m.Kind))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Course)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Knowledge)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovQuestion(uint64(m.Page))
	}
	return n
}

func (m *QueryQuestionReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Currentpage != 0 {
		n += 1 + sovQuestion(uint64(m.Currentpage))
	}
	if m.Totalpage != 0 {
		n += 1 + sovQuestion(uint64(m.Totalpage))
	}
	return n
}

func (m *CreateHomeWorkReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Classid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Students) > 0 {
		for _, s := range m.Students {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if len(m.Questions) > 0 {
		for _, s := range m.Questions {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *CreateHomeWorkReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Homeworkid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QueryMyHomeWorkReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Classid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QuestionInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Questionid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovQuestion(uint64(m.Kind))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Qimage {
		n += 2
	}
	if m.Oimage {
		n += 2
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Score != 0 {
		n += 1 + sovQuestion(uint64(m.Score))
	}
	return n
}

func (m *HomeWorkInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Homeworkid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *QueryMyHomeWorkReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Homework) > 0 {
		for _, e := range m.Homework {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *DoQuestionInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Questionid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Aimage {
		n += 2
	}
	return n
}

func (m *DoHomeWorkReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Homeworkid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Answer) > 0 {
		for _, e := range m.Answer {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *QueryAnswerRecordReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Homeworkid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *UserAnswerInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *AllUserAnswerInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Questionid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if len(m.Rightanswer) > 0 {
		for _, s := range m.Rightanswer {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if len(m.Alluseranswer) > 0 {
		for _, e := range m.Alluseranswer {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *QueryAnswerRecordReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Homeworkrecord) > 0 {
		for _, e := range m.Homeworkrecord {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *QueryHomeWorkInClassReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Homework) > 0 {
		for _, e := range m.Homework {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *CreatePracticeSummaryReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Ownerid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Classid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Pstype != 0 {
		n += 1 + sovQuestion(uint64(m.Pstype))
	}
	l = len(m.Introduction)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Ownername)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *CreatePracticeSummaryReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Practicesummaryid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QueryPracticeSummaryReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Practicesummaryid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovQuestion(uint64(m.Page))
	}
	return n
}

func (m *PracticeSummaryInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Practicesummaryid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Introduction)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Questionnumbers != 0 {
		n += 1 + sovQuestion(uint64(m.Questionnumbers))
	}
	if m.Pstype != 0 {
		n += 1 + sovQuestion(uint64(m.Pstype))
	}
	l = len(m.Ownername)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Coursename)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QuestionPre) Size() (n int) {
	var l int
	_ = l
	l = len(m.Questionid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovQuestion(uint64(m.Kind))
	}
	l = len(m.Knowledgename)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Star != 0 {
		n += 1 + sovQuestion(uint64(m.Star))
	}
	return n
}

func (m *PracticeSummaryDetailInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Currentpage != 0 {
		n += 1 + sovQuestion(uint64(m.Currentpage))
	}
	if m.Totalpage != 0 {
		n += 1 + sovQuestion(uint64(m.Totalpage))
	}
	return n
}

func (m *QueryMyPracticeSummaryReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovQuestion(uint64(m.Page))
	}
	return n
}

func (m *QueryMyPracticeSummaryReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Practicesummary) > 0 {
		for _, e := range m.Practicesummary {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Currentpage != 0 {
		n += 1 + sovQuestion(uint64(m.Currentpage))
	}
	if m.Totalpage != 0 {
		n += 1 + sovQuestion(uint64(m.Totalpage))
	}
	return n
}

func (m *ControllQuestionInPSReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Practicesummaryid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Questions) > 0 {
		for _, s := range m.Questions {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *CreatePaperReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Classid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Continuingtime != 0 {
		n += 1 + sovQuestion(uint64(m.Continuingtime))
	}
	return n
}

func (m *CreatePaperReq_QuestionsInPaper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Questionid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovQuestion(uint64(m.Score))
	}
	if m.Needcheck {
		n += 2
	}
	return n
}

func (m *CreatePaperReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Paperid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QueryPaperInClassReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Classid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovQuestion(uint64(m.Page))
	}
	return n
}

func (m *QueryPaperInClassReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Paper) > 0 {
		for _, e := range m.Paper {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Currentpage != 0 {
		n += 1 + sovQuestion(uint64(m.Currentpage))
	}
	if m.Totalpage != 0 {
		n += 1 + sovQuestion(uint64(m.Totalpage))
	}
	return n
}

func (m *QueryPaperQuestionsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Paperid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QueryPaperQuestionsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Paper) > 0 {
		for _, e := range m.Paper {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Totalscore != 0 {
		n += 1 + sovQuestion(uint64(m.Totalscore))
	}
	if m.Continuingtime != 0 {
		n += 1 + sovQuestion(uint64(m.Continuingtime))
	}
	return n
}

func (m *PaperInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Paperid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Totalscore != 0 {
		n += 1 + sovQuestion(uint64(m.Totalscore))
	}
	if m.Continuingtime != 0 {
		n += 1 + sovQuestion(uint64(m.Continuingtime))
	}
	return n
}

func (m *DoPaperReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Paperid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Answer) > 0 {
		for _, e := range m.Answer {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *QueryPaperAnswerRecordReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Paperid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QueryPaperAnswerRecordReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Paperid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Papername)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Totalscore != 0 {
		n += 1 + sovQuestion(uint64(m.Totalscore))
	}
	if m.Getscore != 0 {
		n += 1 + sovQuestion(uint64(m.Getscore))
	}
	if m.Needcheck {
		n += 2
	}
	if len(m.Paperrecord) > 0 {
		for _, e := range m.Paperrecord {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *UserPaperAnswerInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Questionid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovQuestion(uint64(m.Kind))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Qimage {
		n += 2
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Oimage {
		n += 2
	}
	if len(m.Rightanswer) > 0 {
		for _, s := range m.Rightanswer {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Raimage {
		n += 2
	}
	if len(m.Useranswer) > 0 {
		for _, s := range m.Useranswer {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Uaimage {
		n += 2
	}
	if m.Needcheck {
		n += 2
	}
	l = len(m.Explain)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Star != 0 {
		n += 1 + sovQuestion(uint64(m.Star))
	}
	return n
}

func sovQuestion(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozQuestion(x uint64) (n int) {
	return sovQuestion(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CRqQueryMyQuestionInfoBySubject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CRqQueryMyQuestionInfoBySubject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CRqQueryMyQuestionInfoBySubject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endtime", wireType)
			}
			m.Endtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Endtime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CRpMyQuestionInfoBySubject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CRpMyQuestionInfoBySubject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CRpMyQuestionInfoBySubject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Knowledgenodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Knowledgenodes = append(m.Knowledgenodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateQuestionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateQuestionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateQuestionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Qimage = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = append(m.Option, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Oimage = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answer = append(m.Answer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Aimage = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Course = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Knowledge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Knowledge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Needcheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Needcheck = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Explain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Explain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuestionInfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuestionInfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuestionInfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Qimage = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = append(m.Option, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Oimage = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answer = append(m.Answer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Aimage = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Course = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Knowledge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Knowledge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Needcheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Needcheck = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Explain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Explain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryQuestionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryQuestionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryQuestionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Course = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Knowledge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Knowledge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryQuestionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryQuestionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryQuestionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &QuestionInfoReply{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currentpage", wireType)
			}
			m.Currentpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Currentpage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Totalpage", wireType)
			}
			m.Totalpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Totalpage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateHomeWorkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateHomeWorkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateHomeWorkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Students", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Students = append(m.Students, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateHomeWorkReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateHomeWorkReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateHomeWorkReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homeworkid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homeworkid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMyHomeWorkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMyHomeWorkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMyHomeWorkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuestionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuestionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuestionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questionid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Qimage = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Oimage = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = append(m.Option, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HomeWorkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HomeWorkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HomeWorkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homeworkid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homeworkid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &QuestionInfo{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMyHomeWorkReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMyHomeWorkReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMyHomeWorkReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homework", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homework = append(m.Homework, &HomeWorkInfo{})
			if err := m.Homework[len(m.Homework)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoQuestionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoQuestionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoQuestionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questionid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answer = append(m.Answer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Aimage = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoHomeWorkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoHomeWorkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoHomeWorkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homeworkid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homeworkid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answer = append(m.Answer, &DoQuestionInfo{})
			if err := m.Answer[len(m.Answer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAnswerRecordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnswerRecordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnswerRecordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homeworkid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homeworkid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAnswerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAnswerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAnswerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answer = append(m.Answer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllUserAnswerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllUserAnswerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllUserAnswerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questionid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = append(m.Option, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rightanswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rightanswer = append(m.Rightanswer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alluseranswer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alluseranswer = append(m.Alluseranswer, &UserAnswerInfo{})
			if err := m.Alluseranswer[len(m.Alluseranswer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAnswerRecordReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnswerRecordReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnswerRecordReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homeworkrecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homeworkrecord = append(m.Homeworkrecord, &AllUserAnswerInfo{})
			if err := m.Homeworkrecord[len(m.Homeworkrecord)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryHomeWorkInClassReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryHomeWorkInClassReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryHomeWorkInClassReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homework", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homework = append(m.Homework, &HomeWorkInfo{})
			if err := m.Homework[len(m.Homework)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePracticeSummaryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePracticeSummaryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePracticeSummaryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ownerid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ownerid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pstype", wireType)
			}
			m.Pstype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pstype |= (PracticeSummaryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Introduction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Introduction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ownername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ownername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePracticeSummaryReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePracticeSummaryReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePracticeSummaryReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Practicesummaryid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Practicesummaryid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPracticeSummaryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPracticeSummaryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPracticeSummaryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Practicesummaryid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Practicesummaryid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PracticeSummaryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PracticeSummaryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PracticeSummaryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Practicesummaryid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Practicesummaryid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Introduction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Introduction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionnumbers", wireType)
			}
			m.Questionnumbers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Questionnumbers |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pstype", wireType)
			}
			m.Pstype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pstype |= (PracticeSummaryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ownername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ownername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coursename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coursename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuestionPre) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuestionPre: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuestionPre: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questionid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Knowledgename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Knowledgename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PracticeSummaryDetailInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PracticeSummaryDetailInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PracticeSummaryDetailInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &QuestionPre{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currentpage", wireType)
			}
			m.Currentpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Currentpage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Totalpage", wireType)
			}
			m.Totalpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Totalpage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMyPracticeSummaryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMyPracticeSummaryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMyPracticeSummaryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMyPracticeSummaryReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMyPracticeSummaryReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMyPracticeSummaryReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Practicesummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Practicesummary = append(m.Practicesummary, &PracticeSummaryInfo{})
			if err := m.Practicesummary[len(m.Practicesummary)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currentpage", wireType)
			}
			m.Currentpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Currentpage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Totalpage", wireType)
			}
			m.Totalpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Totalpage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllQuestionInPSReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllQuestionInPSReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllQuestionInPSReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Practicesummaryid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Practicesummaryid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePaperReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePaperReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePaperReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &CreatePaperReq_QuestionsInPaper{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Continuingtime", wireType)
			}
			m.Continuingtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Continuingtime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePaperReq_QuestionsInPaper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuestionsInPaper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuestionsInPaper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questionid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Needcheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Needcheck = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePaperReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePaperReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePaperReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paperid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paperid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPaperInClassReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPaperInClassReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPaperInClassReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPaperInClassReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPaperInClassReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPaperInClassReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paper = append(m.Paper, &PaperInfo{})
			if err := m.Paper[len(m.Paper)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currentpage", wireType)
			}
			m.Currentpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Currentpage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Totalpage", wireType)
			}
			m.Totalpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Totalpage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPaperQuestionsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPaperQuestionsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPaperQuestionsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paperid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paperid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPaperQuestionsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPaperQuestionsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPaperQuestionsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paper = append(m.Paper, &QuestionInfo{})
			if err := m.Paper[len(m.Paper)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Totalscore", wireType)
			}
			m.Totalscore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Totalscore |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Continuingtime", wireType)
			}
			m.Continuingtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Continuingtime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaperInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaperInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaperInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paperid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paperid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Totalscore", wireType)
			}
			m.Totalscore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Totalscore |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Continuingtime", wireType)
			}
			m.Continuingtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Continuingtime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoPaperReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoPaperReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoPaperReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paperid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paperid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answer = append(m.Answer, &DoQuestionInfo{})
			if err := m.Answer[len(m.Answer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPaperAnswerRecordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPaperAnswerRecordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPaperAnswerRecordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paperid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paperid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPaperAnswerRecordReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPaperAnswerRecordReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPaperAnswerRecordReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paperid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paperid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Papername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Papername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Totalscore", wireType)
			}
			m.Totalscore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Totalscore |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Getscore", wireType)
			}
			m.Getscore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Getscore |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Needcheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Needcheck = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paperrecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paperrecord = append(m.Paperrecord, &UserPaperAnswerInfo{})
			if err := m.Paperrecord[len(m.Paperrecord)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPaperAnswerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPaperAnswerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPaperAnswerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questionid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Qimage = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = append(m.Option, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Oimage = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rightanswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rightanswer = append(m.Rightanswer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Raimage = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Useranswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Useranswer = append(m.Useranswer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uaimage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Uaimage = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Needcheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Needcheck = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Explain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Explain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuestion(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthQuestion
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowQuestion
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipQuestion(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthQuestion = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuestion   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api/question.proto", fileDescriptorQuestion) }

var fileDescriptorQuestion = []byte{
	// 2353 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x1a, 0x4b, 0x6f, 0x23, 0x49,
	0x39, 0xed, 0x8e, 0xed, 0xf8, 0x73, 0xe2, 0x24, 0x95, 0x79, 0xf4, 0x78, 0x77, 0xe2, 0xa8, 0x80,
	0x55, 0x06, 0x0d, 0xb1, 0x14, 0x18, 0xb4, 0xb0, 0x62, 0xd9, 0x38, 0xce, 0xce, 0x0e, 0x4c, 0xd8,
	0xd9, 0x4a, 0x46, 0xb0, 0x68, 0xb5, 0xc8, 0xb1, 0x6b, 0x92, 0x26, 0x76, 0xb7, 0xa7, 0xbb, 0xcd,
	0x90, 0xbf, 0xb0, 0x67, 0x5e, 0x7b, 0xe0, 0x88, 0xc4, 0x15, 0x6e, 0x5c, 0x10, 0x47, 0x24, 0x24,
	0x1e, 0x17, 0xc4, 0xc9, 0x42, 0xc3, 0x89, 0xe5, 0x66, 0x21, 0xce, 0xa8, 0x5e, 0xdd, 0xd5, 0xed,
	0xb6, 0xdd, 0x8e, 0x66, 0x56, 0x39, 0xec, 0x25, 0xea, 0xd4, 0xf7, 0xd5, 0x57, 0xf5, 0xbd, 0x1f,
	0x65, 0x40, 0xad, 0xbe, 0x5d, 0x7f, 0x3a, 0xa0, 0x7e, 0x60, 0xbb, 0xce, 0x4e, 0xdf, 0x73, 0x03,
	0x17, 0x99, 0xad, 0xbe, 0x5d, 0xfd, 0xd2, 0xa9, 0x1d, 0x9c, 0x0d, 0x4e, 0x76, 0xda, 0x6e, 0xaf,
	0x7e, 0xea, 0x9e, 0xba, 0x75, 0x0e, 0x3b, 0x19, 0x3c, 0xe1, 0xff, 0xf1, 0x7f, 0xf8, 0x97, 0xd8,
	0x53, 0xdd, 0x3f, 0x77, 0xdc, 0x67, 0x5d, 0xda, 0x39, 0xa5, 0xbd, 0x56, 0xff, 0x07, 0x27, 0xad,
	0xf6, 0x39, 0x75, 0x3a, 0xf5, 0x9e, 0xdd, 0xf6, 0x5c, 0x9f, 0x7a, 0x3f, 0xb2, 0xdb, 0xd4, 0xaf,
	0xeb, 0x28, 0xf5, 0x81, 0x4f, 0xbd, 0x3a, 0x3b, 0x9c, 0x7d, 0x48, 0x22, 0x07, 0xf3, 0x12, 0x69,
	0x77, 0x5b, 0xbe, 0xcf, 0xa9, 0xf0, 0x2f, 0x41, 0x06, 0x7f, 0x64, 0x40, 0x6d, 0x9f, 0x3c, 0x7d,
	0x6f, 0x40, 0xbd, 0x8b, 0xc3, 0x8b, 0xf7, 0x24, 0x73, 0x0f, 0x9c, 0x27, 0x6e, 0xe3, 0xe2, 0x68,
	0x70, 0xf2, 0x43, 0xda, 0x0e, 0xd0, 0x2d, 0x30, 0x07, 0x76, 0xc7, 0x32, 0xb6, 0x8c, 0xed, 0x52,
	0xa3, 0xf8, 0xc9, 0xb0, 0xc6, 0xfe, 0x25, 0xec, 0x0f, 0xfa, 0x02, 0x14, 0x7d, 0x81, 0x65, 0xe5,
	0x38, 0xb8, 0xfc, 0xc9, 0xb0, 0xa6, 0x96, 0x88, 0xfa, 0x60, 0x68, 0xd4, 0xe9, 0x04, 0x76, 0x8f,
	0x5a, 0xe6, 0x96, 0xb1, 0x6d, 0x0a, 0x34, 0xb9, 0x44, 0xd4, 0x07, 0x6e, 0x42, 0x75, 0x9f, 0xf4,
	0x27, 0x5d, 0xe3, 0x35, 0xa8, 0x84, 0x0c, 0x39, 0x6e, 0x87, 0xfa, 0x96, 0xb1, 0x65, 0x6e, 0x97,
	0x48, 0x62, 0x15, 0xff, 0x6f, 0x11, 0xd6, 0xf7, 0x3d, 0xda, 0x0a, 0xa8, 0xa2, 0x43, 0xe8, 0x53,
	0xf4, 0x39, 0x58, 0x3c, 0xb7, 0x1d, 0xc1, 0x85, 0xd9, 0x58, 0x1d, 0x0d, 0x6b, 0xe5, 0x27, 0xae,
	0xd7, 0xfb, 0x3a, 0x66, 0xab, 0x98, 0x70, 0x20, 0x43, 0x72, 0x5a, 0x3d, 0x2a, 0x79, 0xd1, 0x90,
	0xd8, 0x2a, 0x26, 0x1c, 0x88, 0xee, 0x42, 0xb1, 0xed, 0x3a, 0x01, 0x75, 0x02, 0xce, 0x4c, 0xa9,
	0x81, 0x46, 0xc3, 0x5a, 0x45, 0xe0, 0x49, 0x00, 0x26, 0x0a, 0x05, 0xdd, 0x81, 0xc2, 0x53, 0xbb,
	0xd7, 0x3a, 0xa5, 0xd6, 0xe2, 0x96, 0xb1, 0xbd, 0xd4, 0x58, 0x1f, 0x0d, 0x6b, 0x2b, 0x02, 0x59,
	0xac, 0x63, 0x22, 0x11, 0x18, 0xaa, 0xdb, 0x67, 0xf7, 0xb5, 0xf2, 0x8c, 0x31, 0x1d, 0x55, 0xac,
	0x63, 0x22, 0x11, 0x38, 0xaa, 0xa0, 0x5a, 0x48, 0x52, 0x75, 0x15, 0x55, 0x37, 0xa4, 0xda, 0x72,
	0xfc, 0x67, 0xd4, 0xb3, 0x8a, 0x49, 0xaa, 0x62, 0x1d, 0x13, 0x89, 0xc0, 0x51, 0x05, 0xd5, 0xa5,
	0x24, 0xd5, 0x96, 0xa2, 0x2a, 0x3e, 0x98, 0x10, 0x94, 0xe2, 0x4b, 0x49, 0x21, 0x48, 0x00, 0x8e,
	0xf4, 0x7f, 0x07, 0x0a, 0x6d, 0x77, 0xe0, 0xf9, 0xd4, 0x02, 0x8e, 0xac, 0x11, 0x16, 0xeb, 0x98,
	0x48, 0x04, 0xb4, 0x0b, 0xa5, 0x50, 0x9f, 0x56, 0x99, 0x63, 0x5f, 0x1b, 0x0d, 0x6b, 0x6b, 0x52,
	0x59, 0x0a, 0x84, 0x49, 0x84, 0xc6, 0xf6, 0x38, 0x94, 0x76, 0xda, 0x67, 0xb4, 0x7d, 0x6e, 0x2d,
	0xf3, 0xab, 0x6b, 0x7b, 0x42, 0x10, 0x26, 0x11, 0x1a, 0x63, 0x80, 0xfe, 0xb8, 0xdf, 0x6d, 0xd9,
	0x8e, 0xb5, 0x92, 0x64, 0x40, 0x02, 0x30, 0x51, 0x28, 0xcc, 0x30, 0xfc, 0xa0, 0xe5, 0x59, 0x95,
	0xa4, 0xf5, 0xb0, 0x55, 0x4c, 0x38, 0x10, 0xff, 0x34, 0x0f, 0xeb, 0xba, 0xe9, 0x12, 0xda, 0xef,
	0x5e, 0xa0, 0xdb, 0x90, 0x0b, 0x9d, 0x67, 0x65, 0x34, 0xac, 0x95, 0xc4, 0x46, 0xbb, 0x83, 0x49,
	0xce, 0xee, 0x84, 0x76, 0x99, 0x9b, 0x66, 0x97, 0x9f, 0x99, 0xdc, 0x55, 0x33, 0x39, 0x15, 0x29,
	0x96, 0xa7, 0x45, 0x8a, 0x98, 0x5d, 0xae, 0xcc, 0x6d, 0x97, 0x95, 0xec, 0x76, 0xb9, 0x3a, 0xcd,
	0x2e, 0xff, 0x6d, 0xc0, 0x1a, 0x0f, 0xf0, 0x73, 0xc7, 0xc3, 0xbb, 0xc9, 0xf0, 0x9e, 0x51, 0xe4,
	0xe6, 0x5c, 0x22, 0x5f, 0xcc, 0x2c, 0xf2, 0x3e, 0x33, 0x94, 0x7c, 0xf2, 0xc6, 0x7d, 0x6e, 0x26,
	0x1c, 0x88, 0xff, 0x6c, 0x00, 0x4a, 0xf0, 0xca, 0x9c, 0xf0, 0x5b, 0x50, 0x52, 0x89, 0x5b, 0xa4,
	0x8d, 0xf2, 0xee, 0x8d, 0x9d, 0x56, 0xdf, 0xde, 0x19, 0xf3, 0x57, 0xfd, 0x1e, 0xe1, 0x16, 0x4c,
	0xa2, 0xed, 0xe8, 0x75, 0x28, 0xb7, 0x07, 0x9e, 0x47, 0x9d, 0x80, 0x5f, 0x47, 0x38, 0xee, 0x8d,
	0xd1, 0xb0, 0x86, 0x24, 0xaf, 0x11, 0x10, 0x13, 0x1d, 0x95, 0x71, 0x1d, 0xb8, 0x41, 0xab, 0xcb,
	0xf7, 0x89, 0x44, 0xa8, 0x9d, 0x16, 0x82, 0x30, 0x89, 0xd0, 0xf0, 0x9f, 0x0c, 0x95, 0xcd, 0xde,
	0x71, 0x7b, 0xf4, 0xbb, 0xae, 0x77, 0x2e, 0xb5, 0xc7, 0xcd, 0xcf, 0x98, 0x95, 0xa8, 0x58, 0xaa,
	0xb7, 0x3b, 0xe3, 0xda, 0x93, 0x00, 0x16, 0x35, 0xc4, 0x17, 0xaa, 0xc3, 0x92, 0x1f, 0x0c, 0x3a,
	0xd4, 0x09, 0x7c, 0xcb, 0xe4, 0x6e, 0xbb, 0x31, 0x1a, 0xd6, 0x56, 0x95, 0x39, 0x09, 0x08, 0x26,
	0x21, 0x12, 0xe3, 0x26, 0x92, 0xe9, 0x22, 0xdf, 0x31, 0x4b, 0x76, 0xf8, 0x21, 0x6c, 0x24, 0x99,
	0x61, 0xea, 0xb9, 0x07, 0x70, 0xe6, 0xf6, 0xe8, 0x33, 0xd7, 0x3b, 0x0f, 0x63, 0xe5, 0xf5, 0xd1,
	0xb0, 0xb6, 0x2e, 0x68, 0x45, 0x30, 0x4c, 0x34, 0x44, 0xdc, 0x93, 0xba, 0x3e, 0xbc, 0xd0, 0x65,
	0x73, 0x07, 0x0a, 0xac, 0x4e, 0x0a, 0x09, 0x69, 0x66, 0x28, 0xd6, 0x31, 0x91, 0x08, 0xf3, 0x49,
	0x08, 0xff, 0x21, 0x07, 0xcb, 0xba, 0xbd, 0xa0, 0xaf, 0x00, 0x28, 0xd6, 0xc2, 0xd3, 0x62, 0x22,
	0x90, 0x20, 0x4c, 0x34, 0xbc, 0x2b, 0x10, 0xf1, 0x05, 0x6a, 0x3e, 0x43, 0x18, 0x97, 0xc9, 0xa1,
	0x30, 0x2b, 0x39, 0xbc, 0x06, 0x79, 0xbf, 0xed, 0x7a, 0xd4, 0x2a, 0x72, 0xa6, 0xd6, 0x46, 0xc3,
	0xda, 0xb2, 0xb4, 0x1c, 0xb7, 0xed, 0x51, 0x4c, 0x04, 0x18, 0xff, 0xc6, 0x80, 0x65, 0xa5, 0x2b,
	0x2e, 0xc2, 0xcb, 0x69, 0x3e, 0x5b, 0xa1, 0x76, 0xa0, 0x1b, 0xa8, 0xc9, 0x9d, 0x7e, 0x7d, 0xcc,
	0xe9, 0x67, 0xdb, 0xec, 0xf7, 0xe1, 0xda, 0x98, 0x95, 0x31, 0xa3, 0x6d, 0xc0, 0x92, 0xba, 0x91,
	0x0c, 0x29, 0x82, 0xba, 0xce, 0x9f, 0xee, 0x43, 0x0a, 0x19, 0x93, 0x70, 0x1f, 0xfe, 0xa5, 0x01,
	0x95, 0xa6, 0x1b, 0x33, 0xaa, 0x7b, 0x29, 0x46, 0xa5, 0x49, 0x24, 0x82, 0xc5, 0xad, 0x2a, 0xca,
	0xb9, 0xb9, 0xec, 0x39, 0xd7, 0x9c, 0x91, 0x73, 0xf1, 0x73, 0x03, 0x56, 0x9a, 0xae, 0xee, 0x5d,
	0x97, 0x54, 0x58, 0xe4, 0x94, 0xb9, 0x59, 0x4e, 0x59, 0x87, 0x25, 0xf6, 0xc5, 0xf5, 0x2b, 0x6c,
	0x5f, 0x13, 0xa2, 0x82, 0x60, 0x12, 0x22, 0xa1, 0x37, 0x43, 0xd6, 0x17, 0xb9, 0x1a, 0x36, 0xb8,
	0x1a, 0xe2, 0x62, 0x9d, 0x22, 0x0f, 0x7c, 0x28, 0x15, 0xbc, 0xc7, 0xff, 0x25, 0xb4, 0xed, 0x7a,
	0x9d, 0xcb, 0xb3, 0x8a, 0x7f, 0x6e, 0x40, 0xe5, 0xb1, 0x4f, 0x3d, 0x41, 0x8e, 0xeb, 0x54, 0x67,
	0xc9, 0xc8, 0xc2, 0xd2, 0x1c, 0xe2, 0x8a, 0x14, 0x6f, 0xce, 0x50, 0x3c, 0xfe, 0x6d, 0x0e, 0xd6,
	0xf7, 0xba, 0xdd, 0xc4, 0xe5, 0x2e, 0x69, 0x70, 0x5a, 0x84, 0xca, 0x65, 0x8a, 0x50, 0x32, 0x96,
	0x98, 0xb3, 0x62, 0xc9, 0xeb, 0x50, 0xf6, 0xec, 0xd3, 0xb3, 0x40, 0xd3, 0x69, 0x49, 0xcf, 0xaf,
	0x1a, 0x10, 0x13, 0x1d, 0x15, 0x1d, 0xc1, 0x4a, 0xab, 0xdb, 0x65, 0x72, 0x91, 0x7b, 0xf3, 0x9a,
	0x3d, 0xc4, 0xb9, 0x6e, 0x58, 0xa3, 0x61, 0xed, 0x9a, 0x14, 0x93, 0xbe, 0x07, 0x93, 0x38, 0x0d,
	0xec, 0xc3, 0x8d, 0x14, 0xeb, 0x60, 0x01, 0xe0, 0x7d, 0xa8, 0x28, 0xb5, 0x7b, 0x7c, 0x39, 0x56,
	0x59, 0x8c, 0x09, 0xba, 0x71, 0x6b, 0x34, 0xac, 0x5d, 0x8f, 0xdb, 0x8e, 0xd8, 0x87, 0x49, 0x82,
	0x10, 0xa6, 0x70, 0x8b, 0x1f, 0x1a, 0xc5, 0x92, 0x7d, 0x96, 0x84, 0xc4, 0xb9, 0xef, 0x64, 0x09,
	0x3c, 0x53, 0x0e, 0x8b, 0xc2, 0xcf, 0xdf, 0x72, 0x60, 0x89, 0x7c, 0xfc, 0xc8, 0x6b, 0xb5, 0x03,
	0xbb, 0x4d, 0x8f, 0x06, 0xbd, 0x5e, 0xcb, 0xbb, 0x98, 0xa7, 0xc6, 0x70, 0x9f, 0x39, 0x9a, 0xa5,
	0x6a, 0x56, 0x20, 0x01, 0x98, 0x28, 0x14, 0x3d, 0xdf, 0x9a, 0xb3, 0x2b, 0x92, 0x7d, 0x28, 0xf4,
	0xfd, 0xe0, 0xa2, 0x2f, 0xb2, 0x5a, 0x65, 0xd7, 0xe2, 0x5c, 0x26, 0x6e, 0x7a, 0x7c, 0xd1, 0xa7,
	0xba, 0x35, 0x89, 0x1d, 0x98, 0xc8, 0xad, 0xe8, 0x0d, 0x58, 0xb6, 0x9d, 0xc0, 0x73, 0x3b, 0x83,
	0xb6, 0xec, 0x73, 0xd8, 0xb9, 0x37, 0x47, 0xc3, 0xda, 0x86, 0x6c, 0xc4, 0x34, 0x28, 0x26, 0x31,
	0x64, 0x56, 0xe2, 0xf0, 0xab, 0x73, 0x39, 0x14, 0x92, 0xf9, 0x3d, 0x04, 0x61, 0x12, 0xa1, 0xe1,
	0x33, 0xa8, 0x4e, 0x10, 0xa9, 0x28, 0x44, 0xd7, 0xfb, 0x72, 0xdd, 0x17, 0xeb, 0xa1, 0xcf, 0xbd,
	0x3a, 0x1a, 0xd6, 0x2c, 0xc9, 0x44, 0x12, 0x05, 0x93, 0xf1, 0x6d, 0xf8, 0x23, 0x03, 0x6e, 0x72,
	0x2b, 0x49, 0x51, 0xde, 0x0b, 0x3c, 0x27, 0x2c, 0xbc, 0x73, 0xd3, 0x0a, 0xef, 0xdf, 0x99, 0xb0,
	0x91, 0xb8, 0x07, 0x8f, 0x2e, 0x2f, 0xf8, 0x22, 0xb3, 0xb3, 0x7e, 0x52, 0xe1, 0xe6, 0x3c, 0x0a,
	0x6f, 0xc2, 0xaa, 0x0a, 0x71, 0xce, 0xa0, 0x77, 0x42, 0x3d, 0x9f, 0xdb, 0x9e, 0xd9, 0xa8, 0x8e,
	0x86, 0xb5, 0x1b, 0xf1, 0x80, 0x28, 0x11, 0x30, 0x49, 0x6e, 0xd1, 0x0c, 0x37, 0x7f, 0x79, 0xc3,
	0xbd, 0x84, 0xed, 0xb1, 0x50, 0x2e, 0x1a, 0x2c, 0xbe, 0xa9, 0x98, 0x0c, 0xe5, 0x11, 0x0c, 0x13,
	0x0d, 0x11, 0x8f, 0x0c, 0x28, 0xab, 0x64, 0xf9, 0xc8, 0xa3, 0x2f, 0xb3, 0xae, 0x7d, 0x13, 0x56,
	0xa2, 0x71, 0x5d, 0x94, 0xe1, 0xb5, 0x68, 0x1c, 0x03, 0x63, 0x12, 0x47, 0x0f, 0x4d, 0x60, 0x71,
	0x9a, 0x09, 0xa8, 0xae, 0x38, 0x3f, 0xad, 0x2b, 0xfe, 0x8b, 0x01, 0xb7, 0x12, 0x2a, 0x69, 0xd2,
	0xa0, 0x65, 0x77, 0xb9, 0xd9, 0x36, 0xc7, 0x1b, 0xc6, 0xb5, 0x58, 0xed, 0xf8, 0xc8, 0xa3, 0x57,
	0xad, 0x55, 0x3c, 0x97, 0x49, 0xe3, 0x30, 0x2d, 0x20, 0xcc, 0xd1, 0x15, 0x65, 0xf2, 0xf7, 0xff,
	0x18, 0xf0, 0xca, 0xa4, 0xd3, 0x58, 0xa0, 0xfb, 0x10, 0x56, 0x13, 0x0e, 0x2c, 0xc5, 0x98, 0xea,
	0x0c, 0x3c, 0x65, 0x69, 0x3e, 0x96, 0xd8, 0x8a, 0x49, 0x92, 0xd8, 0xa7, 0x2c, 0xda, 0x8f, 0x0d,
	0xb8, 0xb9, 0xef, 0xb2, 0x48, 0xd1, 0xed, 0x46, 0x65, 0xe5, 0xa3, 0xa3, 0x17, 0x1d, 0x6a, 0x63,
	0x3d, 0x75, 0x2e, 0x5b, 0x4f, 0xfd, 0x6b, 0x13, 0x2a, 0x32, 0xe3, 0xb4, 0xfa, 0xac, 0x42, 0x79,
	0x29, 0xe3, 0x81, 0xef, 0x25, 0xbb, 0xfd, 0xf2, 0xee, 0xe7, 0xb9, 0x26, 0xe3, 0x47, 0x87, 0xfe,
	0xe1, 0x3f, 0x70, 0xf8, 0xda, 0x6c, 0x27, 0xd9, 0x83, 0x0a, 0xab, 0x12, 0x6d, 0x67, 0x60, 0x3b,
	0xa7, 0xfc, 0x8d, 0x40, 0xf8, 0xad, 0x56, 0xc1, 0xc4, 0xe1, 0x98, 0x24, 0x36, 0x54, 0x7f, 0x25,
	0x26, 0x5c, 0xb1, 0x83, 0x2f, 0x5b, 0xd7, 0x86, 0xad, 0x6c, 0x6e, 0xac, 0x95, 0xe5, 0x2d, 0xac,
	0x6c, 0x65, 0xe3, 0xc3, 0x3d, 0x33, 0xd3, 0x70, 0x0f, 0xbf, 0x05, 0x6b, 0x31, 0x71, 0x31, 0x47,
	0xb9, 0x0b, 0xc5, 0x3e, 0xfb, 0x2f, 0xbc, 0xa3, 0xa6, 0x06, 0x09, 0xc0, 0x44, 0xa1, 0xe0, 0x9f,
	0x18, 0xb2, 0x59, 0xe1, 0x14, 0xc2, 0xb2, 0xf0, 0xe5, 0x4d, 0x3d, 0xc2, 0x68, 0x60, 0x4e, 0x8b,
	0x06, 0xbf, 0x37, 0x64, 0x95, 0x1c, 0xbf, 0x16, 0xe3, 0xef, 0xab, 0x90, 0xe7, 0x97, 0x97, 0xee,
	0x5f, 0x11, 0xee, 0x2f, 0xd0, 0x9e, 0xb8, 0xba, 0x7c, 0x39, 0x1a, 0x26, 0x02, 0xfd, 0x53, 0x76,
	0xf0, 0xb7, 0xf5, 0xfb, 0x87, 0xa6, 0xc4, 0x04, 0x3b, 0x9f, 0x7e, 0xfe, 0x6b, 0x80, 0x95, 0x4a,
	0x88, 0x89, 0xe2, 0x6b, 0x71, 0x51, 0xa4, 0x0c, 0x23, 0x26, 0x4a, 0x23, 0x53, 0xe9, 0x73, 0x0f,
	0x80, 0x73, 0x24, 0xec, 0x57, 0x70, 0xae, 0x59, 0x7c, 0x04, 0xc3, 0x44, 0x43, 0x4c, 0x71, 0xc0,
	0xc5, 0x39, 0x1d, 0x10, 0xff, 0xc3, 0x80, 0x52, 0xa8, 0xd3, 0xf9, 0x44, 0x76, 0xd5, 0x59, 0xfb,
	0xbb, 0x01, 0xd0, 0x74, 0xc3, 0xd0, 0x3a, 0x1f, 0x6f, 0x57, 0x79, 0xec, 0x11, 0xc8, 0x72, 0x81,
	0xb3, 0x96, 0x9c, 0x7d, 0xbc, 0x2c, 0x36, 0xf1, 0x28, 0x27, 0xeb, 0x86, 0x94, 0x63, 0xe7, 0x0e,
	0x87, 0xcc, 0xd5, 0xf9, 0xa7, 0x66, 0x40, 0x9a, 0xab, 0x87, 0x20, 0x4c, 0x22, 0xb4, 0xcb, 0x9a,
	0x52, 0x1d, 0x96, 0x4e, 0x69, 0x20, 0x36, 0x09, 0x23, 0xd2, 0xf4, 0xa3, 0x20, 0x98, 0x84, 0x48,
	0xf1, 0x04, 0x91, 0xcf, 0xf6, 0xfa, 0xf3, 0x18, 0xca, 0xfc, 0xa2, 0x72, 0x9e, 0x50, 0xd0, 0x2a,
	0xa6, 0xc7, 0x3e, 0xf5, 0x34, 0x99, 0xcd, 0x6a, 0xf2, 0x75, 0x3a, 0xf8, 0xe3, 0x3c, 0x6c, 0xa4,
	0xec, 0xbf, 0x6c, 0x8a, 0xcc, 0x54, 0xe9, 0x2b, 0xb7, 0x36, 0x33, 0xbe, 0xa5, 0x2f, 0xce, 0x33,
	0xe6, 0xce, 0x67, 0x7f, 0xd8, 0x2c, 0x64, 0x7f, 0xd8, 0x2c, 0xce, 0x9a, 0x88, 0x27, 0x46, 0x53,
	0x4b, 0xd9, 0x47, 0x53, 0x77, 0xa1, 0xe8, 0xc9, 0xa1, 0x6b, 0x89, 0x9f, 0xa2, 0x31, 0xea, 0xa9,
	0xa9, 0xab, 0x42, 0x61, 0x7a, 0xd1, 0xa6, 0x58, 0xc0, 0x8f, 0xd1, 0xf4, 0xa2, 0x4f, 0xab, 0x34,
	0x44, 0x76, 0xc8, 0x40, 0x1e, 0x52, 0x4e, 0x1e, 0x32, 0x08, 0x0f, 0x91, 0x5f, 0x57, 0xe4, 0xd5,
	0xfc, 0x8b, 0x6f, 0x8d, 0xcd, 0x0d, 0x58, 0x67, 0x8c, 0xca, 0x50, 0x6c, 0x1e, 0xbc, 0xbd, 0xf7,
	0xf8, 0xe1, 0xf1, 0xda, 0x02, 0xaa, 0x00, 0xec, 0xbf, 0xfb, 0xf0, 0xe1, 0xc1, 0xfe, 0xf1, 0x83,
	0x77, 0xbf, 0xb3, 0x66, 0xa0, 0x65, 0x58, 0x3a, 0x7c, 0x70, 0x74, 0xbc, 0xf7, 0xed, 0x83, 0xa3,
	0xb5, 0xdc, 0xee, 0xcf, 0xca, 0xb0, 0xa4, 0x82, 0x1e, 0xfa, 0x00, 0xd6, 0xef, 0xd3, 0x20, 0xfe,
	0x1b, 0x12, 0x24, 0x2b, 0xd5, 0xe9, 0xbf, 0x73, 0xa9, 0xd6, 0x24, 0xd6, 0xa4, 0x5f, 0xa0, 0xe0,
	0x05, 0xd4, 0x50, 0xa5, 0x76, 0x78, 0xde, 0x0d, 0xad, 0x08, 0xd6, 0xde, 0x57, 0xab, 0x13, 0x9e,
	0x17, 0xf1, 0x02, 0xda, 0x83, 0x95, 0xd8, 0x0b, 0x25, 0xba, 0xae, 0x50, 0x63, 0x2f, 0xb4, 0xd5,
	0x9b, 0x69, 0xcb, 0x82, 0x44, 0x53, 0x5d, 0x43, 0x8d, 0xfc, 0x62, 0xd7, 0xd0, 0xc6, 0xf5, 0x55,
	0x2b, 0x75, 0x5d, 0x50, 0xb9, 0x0f, 0xab, 0x89, 0x87, 0x0d, 0xa4, 0x9d, 0x19, 0x7b, 0x54, 0xab,
	0xde, 0x4a, 0x07, 0x08, 0x42, 0x3b, 0x2c, 0x43, 0x86, 0x34, 0x90, 0xcc, 0x43, 0xfa, 0x76, 0xe0,
	0x6b, 0x07, 0xbd, 0x7e, 0xc0, 0xf0, 0x0f, 0xf9, 0xef, 0x24, 0xe2, 0x23, 0x55, 0xa4, 0x9d, 0x90,
	0x48, 0x46, 0xd5, 0x57, 0x26, 0x81, 0x14, 0x1f, 0xd7, 0xd2, 0x86, 0xa5, 0x68, 0x45, 0xf0, 0x2e,
	0x2b, 0xe4, 0xea, 0x66, 0x44, 0x25, 0x6d, 0xac, 0x8a, 0x17, 0xd0, 0xfb, 0x70, 0x3d, 0x75, 0x74,
	0x87, 0x6e, 0xeb, 0x9d, 0xce, 0x58, 0x6f, 0xad, 0x0c, 0x67, 0xe2, 0xd4, 0x0f, 0x2f, 0xa0, 0x63,
	0x55, 0x16, 0xa6, 0x8c, 0xc8, 0x5e, 0x8d, 0x2e, 0x96, 0x42, 0x7c, 0x62, 0xbf, 0xcc, 0xa9, 0xa2,
	0xfb, 0x34, 0x48, 0xde, 0x76, 0x3a, 0xbd, 0xcd, 0x34, 0x7a, 0xd1, 0xe4, 0x03, 0x2f, 0xa0, 0x0f,
	0x64, 0x2d, 0x3c, 0xd6, 0xd9, 0xa3, 0x4d, 0xdd, 0x0a, 0x52, 0x68, 0x6f, 0x4d, 0x85, 0x0b, 0x49,
	0x7c, 0x03, 0x56, 0xf7, 0x3a, 0x1d, 0xbd, 0x89, 0x96, 0x17, 0x9e, 0xd0, 0x5f, 0x27, 0x6c, 0xe7,
	0x9b, 0xb0, 0xde, 0xa4, 0xdd, 0xc8, 0xd7, 0xe6, 0x26, 0xf0, 0x06, 0x94, 0xb5, 0x1e, 0x0c, 0x6d,
	0xa4, 0x34, 0xb1, 0xd5, 0xeb, 0xe3, 0x8b, 0xe2, 0xf2, 0xca, 0x72, 0xf5, 0x36, 0x47, 0xb7, 0xdc,
	0x44, 0x57, 0xa6, 0x5b, 0xee, 0x58, 0x67, 0x84, 0x17, 0xd0, 0x11, 0x6c, 0xa4, 0x34, 0x0b, 0x28,
	0xb9, 0x4b, 0xef, 0x47, 0xaa, 0xb7, 0x27, 0x03, 0x05, 0xd1, 0x6d, 0x28, 0xca, 0x7a, 0x15, 0xad,
	0x4a, 0x57, 0x0c, 0x19, 0x8b, 0x8b, 0xe2, 0x43, 0x69, 0x94, 0x87, 0xe3, 0xc5, 0x98, 0xae, 0xea,
	0xb4, 0x02, 0x51, 0x57, 0x75, 0x7a, 0x25, 0x87, 0x17, 0x1a, 0x6b, 0x7f, 0x7c, 0xbe, 0x69, 0xfc,
	0xf5, 0xf9, 0xa6, 0xf1, 0xcf, 0xe7, 0x9b, 0xc6, 0x2f, 0xfe, 0xb5, 0xb9, 0x70, 0x52, 0xe0, 0xbf,
	0x3a, 0xfc, 0xf2, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x45, 0xcd, 0x6a, 0x23, 0x4b, 0x29, 0x00,
	0x00,
}
