// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/question.proto

/*
	Package api is a generated protocol buffer package.

	It is generated from these files:
		api/question.proto

	It has these top-level messages:
		CRqQueryMyQuestionInfoBySubject
		CRpMyQuestionInfoBySubject
		CreateQuestionReq
		QuestionInfoReply
		QueryQuestionReq
		QueryQuestionReply
		CreateHomeWorkReq
		CreateHomeWorkReply
		QueryMyHomeWorkReq
		QuestionInfo
		HomeWorkInfo
		QueryMyHomeWorkReply
		DoHomeWorkInfo
		DoHomeWorkReq
		QueryAnswerRecordReq
		UserAnswerInfo
		AllUserAnswerInfo
		QueryAnswerRecordReply
		QueryHomeWorkInClassReply
		CreatePracticeSummaryReq
		CreatePracticeSummaryReply
		QueryPracticeSummaryReq
		PracticeSummaryInfo
		QuestionPre
		PracticeSummaryDetailInfo
		QueryMyPracticeSummaryReq
		QueryMyPracticeSummaryReply
		ControllQuestionInPSReq
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "knowledgemap_backend/microservices/knowledgemap/user/api"
import _ "knowledgemap_backend/microservices/knowledgemap/class/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type PracticeSummaryType int32

const (
	PracticeSummaryType_DEFAULT    PracticeSummaryType = 0
	PracticeSummaryType_COLLECTION PracticeSummaryType = 1
	PracticeSummaryType_MISTAKES   PracticeSummaryType = 2
)

var PracticeSummaryType_name = map[int32]string{
	0: "DEFAULT",
	1: "COLLECTION",
	2: "MISTAKES",
}
var PracticeSummaryType_value = map[string]int32{
	"DEFAULT":    0,
	"COLLECTION": 1,
	"MISTAKES":   2,
}

func (x PracticeSummaryType) String() string {
	return proto.EnumName(PracticeSummaryType_name, int32(x))
}
func (PracticeSummaryType) EnumDescriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{0} }

type CRqQueryMyQuestionInfoBySubject struct {
	Uid     string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Subject string `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject"`
	Endtime int64  `protobuf:"varint,3,opt,name=endtime,proto3" json:"endtime"`
}

func (m *CRqQueryMyQuestionInfoBySubject) Reset()         { *m = CRqQueryMyQuestionInfoBySubject{} }
func (m *CRqQueryMyQuestionInfoBySubject) String() string { return proto.CompactTextString(m) }
func (*CRqQueryMyQuestionInfoBySubject) ProtoMessage()    {}
func (*CRqQueryMyQuestionInfoBySubject) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{0}
}

func (m *CRqQueryMyQuestionInfoBySubject) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *CRqQueryMyQuestionInfoBySubject) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *CRqQueryMyQuestionInfoBySubject) GetEndtime() int64 {
	if m != nil {
		return m.Endtime
	}
	return 0
}

type CRpMyQuestionInfoBySubject struct {
	Knowledgenodes []string `protobuf:"bytes,1,rep,name=knowledgenodes" json:"knowledgenodes,omitempty"`
}

func (m *CRpMyQuestionInfoBySubject) Reset()         { *m = CRpMyQuestionInfoBySubject{} }
func (m *CRpMyQuestionInfoBySubject) String() string { return proto.CompactTextString(m) }
func (*CRpMyQuestionInfoBySubject) ProtoMessage()    {}
func (*CRpMyQuestionInfoBySubject) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{1}
}

func (m *CRpMyQuestionInfoBySubject) GetKnowledgenodes() []string {
	if m != nil {
		return m.Knowledgenodes
	}
	return nil
}

type CreateQuestionReq struct {
	Kind      int64    `protobuf:"varint,1,opt,name=kind,proto3" json:"kind,omitempty" form:"kind"`
	Content   string   `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty" form:"content"`
	Option    []string `protobuf:"bytes,3,rep,name=option" json:"option,omitempty" form:"option"`
	Answer    []string `protobuf:"bytes,4,rep,name=answer" json:"answer,omitempty" form:"answer"`
	Subject   string   `protobuf:"bytes,5,opt,name=subject,proto3" json:"subject,omitempty" form:"subject"`
	Course    string   `protobuf:"bytes,6,opt,name=course,proto3" json:"course,omitempty" form:"course"`
	Knowledge string   `protobuf:"bytes,7,opt,name=knowledge,proto3" json:"knowledge,omitempty" form:"knowledge"`
}

func (m *CreateQuestionReq) Reset()                    { *m = CreateQuestionReq{} }
func (m *CreateQuestionReq) String() string            { return proto.CompactTextString(m) }
func (*CreateQuestionReq) ProtoMessage()               {}
func (*CreateQuestionReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{2} }

func (m *CreateQuestionReq) GetKind() int64 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *CreateQuestionReq) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *CreateQuestionReq) GetOption() []string {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *CreateQuestionReq) GetAnswer() []string {
	if m != nil {
		return m.Answer
	}
	return nil
}

func (m *CreateQuestionReq) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *CreateQuestionReq) GetCourse() string {
	if m != nil {
		return m.Course
	}
	return ""
}

func (m *CreateQuestionReq) GetKnowledge() string {
	if m != nil {
		return m.Knowledge
	}
	return ""
}

type QuestionInfoReply struct {
	Id        string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" form:"id"`
	Kind      int64    `protobuf:"varint,2,opt,name=kind,proto3" json:"kind,omitempty" form:"kind"`
	Content   string   `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty" form:"content"`
	Option    []string `protobuf:"bytes,4,rep,name=option" json:"option,omitempty" form:"option"`
	Answer    []string `protobuf:"bytes,5,rep,name=answer" json:"answer,omitempty" form:"answer"`
	Subject   string   `protobuf:"bytes,6,opt,name=subject,proto3" json:"subject,omitempty" form:"subject"`
	Course    string   `protobuf:"bytes,7,opt,name=course,proto3" json:"course,omitempty" form:"course"`
	Knowledge string   `protobuf:"bytes,8,opt,name=knowledge,proto3" json:"knowledge,omitempty" form:"knowledge"`
}

func (m *QuestionInfoReply) Reset()                    { *m = QuestionInfoReply{} }
func (m *QuestionInfoReply) String() string            { return proto.CompactTextString(m) }
func (*QuestionInfoReply) ProtoMessage()               {}
func (*QuestionInfoReply) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{3} }

func (m *QuestionInfoReply) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *QuestionInfoReply) GetKind() int64 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *QuestionInfoReply) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *QuestionInfoReply) GetOption() []string {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *QuestionInfoReply) GetAnswer() []string {
	if m != nil {
		return m.Answer
	}
	return nil
}

func (m *QuestionInfoReply) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *QuestionInfoReply) GetCourse() string {
	if m != nil {
		return m.Course
	}
	return ""
}

func (m *QuestionInfoReply) GetKnowledge() string {
	if m != nil {
		return m.Knowledge
	}
	return ""
}

type QueryQuestionReq struct {
	Kind      int64  `protobuf:"varint,1,opt,name=kind,proto3" json:"kind,omitempty" form:"kind"`
	Subject   string `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject,omitempty" form:"subject"`
	Course    string `protobuf:"bytes,3,opt,name=course,proto3" json:"course,omitempty" form:"course"`
	Knowledge string `protobuf:"bytes,4,opt,name=knowledge,proto3" json:"knowledge,omitempty" form:"knowledge"`
}

func (m *QueryQuestionReq) Reset()                    { *m = QueryQuestionReq{} }
func (m *QueryQuestionReq) String() string            { return proto.CompactTextString(m) }
func (*QueryQuestionReq) ProtoMessage()               {}
func (*QueryQuestionReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{4} }

func (m *QueryQuestionReq) GetKind() int64 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *QueryQuestionReq) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *QueryQuestionReq) GetCourse() string {
	if m != nil {
		return m.Course
	}
	return ""
}

func (m *QueryQuestionReq) GetKnowledge() string {
	if m != nil {
		return m.Knowledge
	}
	return ""
}

type QueryQuestionReply struct {
	Questions []*QuestionInfoReply `protobuf:"bytes,1,rep,name=questions" json:"questions,omitempty" form:"questions"`
}

func (m *QueryQuestionReply) Reset()                    { *m = QueryQuestionReply{} }
func (m *QueryQuestionReply) String() string            { return proto.CompactTextString(m) }
func (*QueryQuestionReply) ProtoMessage()               {}
func (*QueryQuestionReply) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{5} }

func (m *QueryQuestionReply) GetQuestions() []*QuestionInfoReply {
	if m != nil {
		return m.Questions
	}
	return nil
}

type CreateHomeWorkReq struct {
	Name      string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Classid   string   `protobuf:"bytes,2,opt,name=classid,proto3" json:"classid,omitempty" form:"classid"`
	Students  []string `protobuf:"bytes,3,rep,name=students" json:"students,omitempty" form:"students"`
	Questions []string `protobuf:"bytes,4,rep,name=questions" json:"questions,omitempty" form:"questions"`
}

func (m *CreateHomeWorkReq) Reset()                    { *m = CreateHomeWorkReq{} }
func (m *CreateHomeWorkReq) String() string            { return proto.CompactTextString(m) }
func (*CreateHomeWorkReq) ProtoMessage()               {}
func (*CreateHomeWorkReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{6} }

func (m *CreateHomeWorkReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateHomeWorkReq) GetClassid() string {
	if m != nil {
		return m.Classid
	}
	return ""
}

func (m *CreateHomeWorkReq) GetStudents() []string {
	if m != nil {
		return m.Students
	}
	return nil
}

func (m *CreateHomeWorkReq) GetQuestions() []string {
	if m != nil {
		return m.Questions
	}
	return nil
}

type CreateHomeWorkReply struct {
	Homeworkid string `protobuf:"bytes,1,opt,name=homeworkid,proto3" json:"homeworkid,omitempty" form:"homeworkid"`
}

func (m *CreateHomeWorkReply) Reset()                    { *m = CreateHomeWorkReply{} }
func (m *CreateHomeWorkReply) String() string            { return proto.CompactTextString(m) }
func (*CreateHomeWorkReply) ProtoMessage()               {}
func (*CreateHomeWorkReply) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{7} }

func (m *CreateHomeWorkReply) GetHomeworkid() string {
	if m != nil {
		return m.Homeworkid
	}
	return ""
}

type QueryMyHomeWorkReq struct {
	Userid  string `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty" form:"userid"`
	Classid string `protobuf:"bytes,2,opt,name=classid,proto3" json:"classid,omitempty" form:"classid"`
}

func (m *QueryMyHomeWorkReq) Reset()                    { *m = QueryMyHomeWorkReq{} }
func (m *QueryMyHomeWorkReq) String() string            { return proto.CompactTextString(m) }
func (*QueryMyHomeWorkReq) ProtoMessage()               {}
func (*QueryMyHomeWorkReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{8} }

func (m *QueryMyHomeWorkReq) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *QueryMyHomeWorkReq) GetClassid() string {
	if m != nil {
		return m.Classid
	}
	return ""
}

type QuestionInfo struct {
	Questionid string   `protobuf:"bytes,1,opt,name=questionid,proto3" json:"questionid,omitempty" form:"qustionid"`
	Kind       int64    `protobuf:"varint,2,opt,name=kind,proto3" json:"kind,omitempty" form:"kind"`
	Content    string   `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty" form:"content"`
	Option     []string `protobuf:"bytes,4,rep,name=option" json:"option,omitempty" form:"option"`
}

func (m *QuestionInfo) Reset()                    { *m = QuestionInfo{} }
func (m *QuestionInfo) String() string            { return proto.CompactTextString(m) }
func (*QuestionInfo) ProtoMessage()               {}
func (*QuestionInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{9} }

func (m *QuestionInfo) GetQuestionid() string {
	if m != nil {
		return m.Questionid
	}
	return ""
}

func (m *QuestionInfo) GetKind() int64 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *QuestionInfo) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *QuestionInfo) GetOption() []string {
	if m != nil {
		return m.Option
	}
	return nil
}

type HomeWorkInfo struct {
	Homeworkid string          `protobuf:"bytes,1,opt,name=homeworkid,proto3" json:"homeworkid,omitempty" form:"homeworkid"`
	Name       string          `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Questions  []*QuestionInfo `protobuf:"bytes,3,rep,name=questions" json:"questions,omitempty" form:"questions"`
}

func (m *HomeWorkInfo) Reset()                    { *m = HomeWorkInfo{} }
func (m *HomeWorkInfo) String() string            { return proto.CompactTextString(m) }
func (*HomeWorkInfo) ProtoMessage()               {}
func (*HomeWorkInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{10} }

func (m *HomeWorkInfo) GetHomeworkid() string {
	if m != nil {
		return m.Homeworkid
	}
	return ""
}

func (m *HomeWorkInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HomeWorkInfo) GetQuestions() []*QuestionInfo {
	if m != nil {
		return m.Questions
	}
	return nil
}

type QueryMyHomeWorkReply struct {
	Homework []*HomeWorkInfo `protobuf:"bytes,1,rep,name=homework" json:"homework,omitempty" form:"homework"`
}

func (m *QueryMyHomeWorkReply) Reset()                    { *m = QueryMyHomeWorkReply{} }
func (m *QueryMyHomeWorkReply) String() string            { return proto.CompactTextString(m) }
func (*QueryMyHomeWorkReply) ProtoMessage()               {}
func (*QueryMyHomeWorkReply) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{11} }

func (m *QueryMyHomeWorkReply) GetHomework() []*HomeWorkInfo {
	if m != nil {
		return m.Homework
	}
	return nil
}

type DoHomeWorkInfo struct {
	Questionid string   `protobuf:"bytes,1,opt,name=questionid,proto3" json:"questionid,omitempty" form:"questionid"`
	Answer     []string `protobuf:"bytes,2,rep,name=answer" json:"answer,omitempty" form:"answer"`
}

func (m *DoHomeWorkInfo) Reset()                    { *m = DoHomeWorkInfo{} }
func (m *DoHomeWorkInfo) String() string            { return proto.CompactTextString(m) }
func (*DoHomeWorkInfo) ProtoMessage()               {}
func (*DoHomeWorkInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{12} }

func (m *DoHomeWorkInfo) GetQuestionid() string {
	if m != nil {
		return m.Questionid
	}
	return ""
}

func (m *DoHomeWorkInfo) GetAnswer() []string {
	if m != nil {
		return m.Answer
	}
	return nil
}

type DoHomeWorkReq struct {
	Homeworkid string            `protobuf:"bytes,1,opt,name=homeworkid,proto3" json:"homeworkid,omitempty" form:"homeworkid"`
	Userid     string            `protobuf:"bytes,2,opt,name=userid,proto3" json:"userid,omitempty" form:"userid"`
	Username   string            `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty" form:"username"`
	Answer     []*DoHomeWorkInfo `protobuf:"bytes,4,rep,name=answer" json:"answer,omitempty" form:"answer"`
}

func (m *DoHomeWorkReq) Reset()                    { *m = DoHomeWorkReq{} }
func (m *DoHomeWorkReq) String() string            { return proto.CompactTextString(m) }
func (*DoHomeWorkReq) ProtoMessage()               {}
func (*DoHomeWorkReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{13} }

func (m *DoHomeWorkReq) GetHomeworkid() string {
	if m != nil {
		return m.Homeworkid
	}
	return ""
}

func (m *DoHomeWorkReq) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *DoHomeWorkReq) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *DoHomeWorkReq) GetAnswer() []*DoHomeWorkInfo {
	if m != nil {
		return m.Answer
	}
	return nil
}

type QueryAnswerRecordReq struct {
	Homeworkid string `protobuf:"bytes,1,opt,name=homeworkid,proto3" json:"homeworkid,omitempty" form:"homeworkid"`
}

func (m *QueryAnswerRecordReq) Reset()                    { *m = QueryAnswerRecordReq{} }
func (m *QueryAnswerRecordReq) String() string            { return proto.CompactTextString(m) }
func (*QueryAnswerRecordReq) ProtoMessage()               {}
func (*QueryAnswerRecordReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{14} }

func (m *QueryAnswerRecordReq) GetHomeworkid() string {
	if m != nil {
		return m.Homeworkid
	}
	return ""
}

type UserAnswerInfo struct {
	Username string   `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty" form:"username"`
	Userid   string   `protobuf:"bytes,2,opt,name=userid,proto3" json:"userid,omitempty" form:"userid"`
	Answer   []string `protobuf:"bytes,3,rep,name=answer" json:"answer,omitempty" form:"answer"`
}

func (m *UserAnswerInfo) Reset()                    { *m = UserAnswerInfo{} }
func (m *UserAnswerInfo) String() string            { return proto.CompactTextString(m) }
func (*UserAnswerInfo) ProtoMessage()               {}
func (*UserAnswerInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{15} }

func (m *UserAnswerInfo) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserAnswerInfo) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *UserAnswerInfo) GetAnswer() []string {
	if m != nil {
		return m.Answer
	}
	return nil
}

type AllUserAnswerInfo struct {
	Questionid    string            `protobuf:"bytes,1,opt,name=questionid,proto3" json:"questionid,omitempty" form:"questionid"`
	Content       string            `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty" form:"content"`
	Option        []string          `protobuf:"bytes,3,rep,name=option" json:"option,omitempty" form:"option"`
	Rightanswer   []string          `protobuf:"bytes,4,rep,name=rightanswer" json:"rightanswer,omitempty" form:"rightanswer"`
	Alluseranswer []*UserAnswerInfo `protobuf:"bytes,5,rep,name=alluseranswer" json:"alluseranswer,omitempty" form:"alluseranswer"`
}

func (m *AllUserAnswerInfo) Reset()                    { *m = AllUserAnswerInfo{} }
func (m *AllUserAnswerInfo) String() string            { return proto.CompactTextString(m) }
func (*AllUserAnswerInfo) ProtoMessage()               {}
func (*AllUserAnswerInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{16} }

func (m *AllUserAnswerInfo) GetQuestionid() string {
	if m != nil {
		return m.Questionid
	}
	return ""
}

func (m *AllUserAnswerInfo) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *AllUserAnswerInfo) GetOption() []string {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *AllUserAnswerInfo) GetRightanswer() []string {
	if m != nil {
		return m.Rightanswer
	}
	return nil
}

func (m *AllUserAnswerInfo) GetAlluseranswer() []*UserAnswerInfo {
	if m != nil {
		return m.Alluseranswer
	}
	return nil
}

type QueryAnswerRecordReply struct {
	Homeworkrecord []*AllUserAnswerInfo `protobuf:"bytes,1,rep,name=homeworkrecord" json:"homeworkrecord,omitempty" form:"homeworkrecord"`
}

func (m *QueryAnswerRecordReply) Reset()                    { *m = QueryAnswerRecordReply{} }
func (m *QueryAnswerRecordReply) String() string            { return proto.CompactTextString(m) }
func (*QueryAnswerRecordReply) ProtoMessage()               {}
func (*QueryAnswerRecordReply) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{17} }

func (m *QueryAnswerRecordReply) GetHomeworkrecord() []*AllUserAnswerInfo {
	if m != nil {
		return m.Homeworkrecord
	}
	return nil
}

type QueryHomeWorkInClassReply struct {
	Homework []*HomeWorkInfo `protobuf:"bytes,1,rep,name=homework" json:"homework,omitempty" form:"homeworkrecord"`
}

func (m *QueryHomeWorkInClassReply) Reset()         { *m = QueryHomeWorkInClassReply{} }
func (m *QueryHomeWorkInClassReply) String() string { return proto.CompactTextString(m) }
func (*QueryHomeWorkInClassReply) ProtoMessage()    {}
func (*QueryHomeWorkInClassReply) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{18}
}

func (m *QueryHomeWorkInClassReply) GetHomework() []*HomeWorkInfo {
	if m != nil {
		return m.Homework
	}
	return nil
}

type CreatePracticeSummaryReq struct {
	Name         string              `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Ownerid      string              `protobuf:"bytes,2,opt,name=ownerid,proto3" json:"ownerid,omitempty" form:"ownerid"`
	Classid      string              `protobuf:"bytes,3,opt,name=classid,proto3" json:"classid,omitempty" form:"classid"`
	Pstype       PracticeSummaryType `protobuf:"varint,4,opt,name=pstype,proto3,enum=api.PracticeSummaryType" json:"pstype,omitempty" form:"pstype"`
	Introduction string              `protobuf:"bytes,5,opt,name=introduction,proto3" json:"introduction,omitempty" form:"introduction"`
	Ownername    string              `protobuf:"bytes,6,opt,name=ownername,proto3" json:"ownername,omitempty" form:"ownername"`
}

func (m *CreatePracticeSummaryReq) Reset()         { *m = CreatePracticeSummaryReq{} }
func (m *CreatePracticeSummaryReq) String() string { return proto.CompactTextString(m) }
func (*CreatePracticeSummaryReq) ProtoMessage()    {}
func (*CreatePracticeSummaryReq) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{19}
}

func (m *CreatePracticeSummaryReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreatePracticeSummaryReq) GetOwnerid() string {
	if m != nil {
		return m.Ownerid
	}
	return ""
}

func (m *CreatePracticeSummaryReq) GetClassid() string {
	if m != nil {
		return m.Classid
	}
	return ""
}

func (m *CreatePracticeSummaryReq) GetPstype() PracticeSummaryType {
	if m != nil {
		return m.Pstype
	}
	return PracticeSummaryType_DEFAULT
}

func (m *CreatePracticeSummaryReq) GetIntroduction() string {
	if m != nil {
		return m.Introduction
	}
	return ""
}

func (m *CreatePracticeSummaryReq) GetOwnername() string {
	if m != nil {
		return m.Ownername
	}
	return ""
}

type CreatePracticeSummaryReply struct {
	Practicesummaryid string `protobuf:"bytes,1,opt,name=practicesummaryid,proto3" json:"practicesummaryid,omitempty" form:"practicesummaryid"`
}

func (m *CreatePracticeSummaryReply) Reset()         { *m = CreatePracticeSummaryReply{} }
func (m *CreatePracticeSummaryReply) String() string { return proto.CompactTextString(m) }
func (*CreatePracticeSummaryReply) ProtoMessage()    {}
func (*CreatePracticeSummaryReply) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{20}
}

func (m *CreatePracticeSummaryReply) GetPracticesummaryid() string {
	if m != nil {
		return m.Practicesummaryid
	}
	return ""
}

type QueryPracticeSummaryReq struct {
	Practicesummaryid string `protobuf:"bytes,1,opt,name=practicesummaryid,proto3" json:"practicesummaryid,omitempty" form:"practicesummaryid"`
	Page              int64  `protobuf:"varint,2,opt,name=page,proto3" json:"page,omitempty" form:"page"`
}

func (m *QueryPracticeSummaryReq) Reset()                    { *m = QueryPracticeSummaryReq{} }
func (m *QueryPracticeSummaryReq) String() string            { return proto.CompactTextString(m) }
func (*QueryPracticeSummaryReq) ProtoMessage()               {}
func (*QueryPracticeSummaryReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{21} }

func (m *QueryPracticeSummaryReq) GetPracticesummaryid() string {
	if m != nil {
		return m.Practicesummaryid
	}
	return ""
}

func (m *QueryPracticeSummaryReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type PracticeSummaryInfo struct {
	Practicesummaryid string              `protobuf:"bytes,1,opt,name=practicesummaryid,proto3" json:"practicesummaryid,omitempty" form:"practicesummaryid"`
	Name              string              `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Introduction      string              `protobuf:"bytes,3,opt,name=introduction,proto3" json:"introduction,omitempty" form:"introduction"`
	Questionnumbers   int64               `protobuf:"varint,4,opt,name=questionnumbers,proto3" json:"questionnumbers,omitempty" form:"questionnumbers"`
	Pstype            PracticeSummaryType `protobuf:"varint,5,opt,name=pstype,proto3,enum=api.PracticeSummaryType" json:"pstype,omitempty" form:"pstype"`
	Ownername         string              `protobuf:"bytes,6,opt,name=ownername,proto3" json:"ownername,omitempty" form:"ownername"`
	Coursename        string              `protobuf:"bytes,7,opt,name=coursename,proto3" json:"coursename,omitempty" form:"coursename"`
}

func (m *PracticeSummaryInfo) Reset()                    { *m = PracticeSummaryInfo{} }
func (m *PracticeSummaryInfo) String() string            { return proto.CompactTextString(m) }
func (*PracticeSummaryInfo) ProtoMessage()               {}
func (*PracticeSummaryInfo) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{22} }

func (m *PracticeSummaryInfo) GetPracticesummaryid() string {
	if m != nil {
		return m.Practicesummaryid
	}
	return ""
}

func (m *PracticeSummaryInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PracticeSummaryInfo) GetIntroduction() string {
	if m != nil {
		return m.Introduction
	}
	return ""
}

func (m *PracticeSummaryInfo) GetQuestionnumbers() int64 {
	if m != nil {
		return m.Questionnumbers
	}
	return 0
}

func (m *PracticeSummaryInfo) GetPstype() PracticeSummaryType {
	if m != nil {
		return m.Pstype
	}
	return PracticeSummaryType_DEFAULT
}

func (m *PracticeSummaryInfo) GetOwnername() string {
	if m != nil {
		return m.Ownername
	}
	return ""
}

func (m *PracticeSummaryInfo) GetCoursename() string {
	if m != nil {
		return m.Coursename
	}
	return ""
}

type QuestionPre struct {
	Questionid    string `protobuf:"bytes,1,opt,name=questionid,proto3" json:"questionid,omitempty" form:"qustionid"`
	Kind          int64  `protobuf:"varint,2,opt,name=kind,proto3" json:"kind,omitempty" form:"kind"`
	Knowledgename string `protobuf:"bytes,3,opt,name=knowledgename,proto3" json:"knowledgename,omitempty" form:"knowledgename"`
}

func (m *QuestionPre) Reset()                    { *m = QuestionPre{} }
func (m *QuestionPre) String() string            { return proto.CompactTextString(m) }
func (*QuestionPre) ProtoMessage()               {}
func (*QuestionPre) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{23} }

func (m *QuestionPre) GetQuestionid() string {
	if m != nil {
		return m.Questionid
	}
	return ""
}

func (m *QuestionPre) GetKind() int64 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *QuestionPre) GetKnowledgename() string {
	if m != nil {
		return m.Knowledgename
	}
	return ""
}

type PracticeSummaryDetailInfo struct {
	Questions   []*QuestionPre `protobuf:"bytes,1,rep,name=questions" json:"questions,omitempty" form:"questions"`
	Currentpage int64          `protobuf:"varint,2,opt,name=currentpage,proto3" json:"currentpage,omitempty" form:"currentpage"`
	Totalpage   int64          `protobuf:"varint,3,opt,name=totalpage,proto3" json:"totalpage,omitempty" form:"totalpage"`
}

func (m *PracticeSummaryDetailInfo) Reset()         { *m = PracticeSummaryDetailInfo{} }
func (m *PracticeSummaryDetailInfo) String() string { return proto.CompactTextString(m) }
func (*PracticeSummaryDetailInfo) ProtoMessage()    {}
func (*PracticeSummaryDetailInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{24}
}

func (m *PracticeSummaryDetailInfo) GetQuestions() []*QuestionPre {
	if m != nil {
		return m.Questions
	}
	return nil
}

func (m *PracticeSummaryDetailInfo) GetCurrentpage() int64 {
	if m != nil {
		return m.Currentpage
	}
	return 0
}

func (m *PracticeSummaryDetailInfo) GetTotalpage() int64 {
	if m != nil {
		return m.Totalpage
	}
	return 0
}

type QueryMyPracticeSummaryReq struct {
	Userid string `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty" form:"userid"`
	Page   int64  `protobuf:"varint,2,opt,name=page,proto3" json:"page,omitempty" form:"page"`
}

func (m *QueryMyPracticeSummaryReq) Reset()         { *m = QueryMyPracticeSummaryReq{} }
func (m *QueryMyPracticeSummaryReq) String() string { return proto.CompactTextString(m) }
func (*QueryMyPracticeSummaryReq) ProtoMessage()    {}
func (*QueryMyPracticeSummaryReq) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{25}
}

func (m *QueryMyPracticeSummaryReq) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *QueryMyPracticeSummaryReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type QueryMyPracticeSummaryReply struct {
	Practicesummary []*PracticeSummaryInfo `protobuf:"bytes,1,rep,name=practicesummary" json:"practicesummary,omitempty" form:"practicesummary"`
	Currentpage     int64                  `protobuf:"varint,2,opt,name=currentpage,proto3" json:"currentpage,omitempty" form:"currentpage"`
	Totalpage       int64                  `protobuf:"varint,3,opt,name=totalpage,proto3" json:"totalpage,omitempty" form:"totalpage"`
}

func (m *QueryMyPracticeSummaryReply) Reset()         { *m = QueryMyPracticeSummaryReply{} }
func (m *QueryMyPracticeSummaryReply) String() string { return proto.CompactTextString(m) }
func (*QueryMyPracticeSummaryReply) ProtoMessage()    {}
func (*QueryMyPracticeSummaryReply) Descriptor() ([]byte, []int) {
	return fileDescriptorQuestion, []int{26}
}

func (m *QueryMyPracticeSummaryReply) GetPracticesummary() []*PracticeSummaryInfo {
	if m != nil {
		return m.Practicesummary
	}
	return nil
}

func (m *QueryMyPracticeSummaryReply) GetCurrentpage() int64 {
	if m != nil {
		return m.Currentpage
	}
	return 0
}

func (m *QueryMyPracticeSummaryReply) GetTotalpage() int64 {
	if m != nil {
		return m.Totalpage
	}
	return 0
}

type ControllQuestionInPSReq struct {
	Practicesummaryid string   `protobuf:"bytes,1,opt,name=practicesummaryid,proto3" json:"practicesummaryid,omitempty" form:"practicesummaryid"`
	Questions         []string `protobuf:"bytes,2,rep,name=questions" json:"questions,omitempty" form:"questions"`
}

func (m *ControllQuestionInPSReq) Reset()                    { *m = ControllQuestionInPSReq{} }
func (m *ControllQuestionInPSReq) String() string            { return proto.CompactTextString(m) }
func (*ControllQuestionInPSReq) ProtoMessage()               {}
func (*ControllQuestionInPSReq) Descriptor() ([]byte, []int) { return fileDescriptorQuestion, []int{27} }

func (m *ControllQuestionInPSReq) GetPracticesummaryid() string {
	if m != nil {
		return m.Practicesummaryid
	}
	return ""
}

func (m *ControllQuestionInPSReq) GetQuestions() []string {
	if m != nil {
		return m.Questions
	}
	return nil
}

func init() {
	proto.RegisterType((*CRqQueryMyQuestionInfoBySubject)(nil), "api.CRqQueryMyQuestionInfoBySubject")
	proto.RegisterType((*CRpMyQuestionInfoBySubject)(nil), "api.CRpMyQuestionInfoBySubject")
	proto.RegisterType((*CreateQuestionReq)(nil), "api.CreateQuestionReq")
	proto.RegisterType((*QuestionInfoReply)(nil), "api.QuestionInfoReply")
	proto.RegisterType((*QueryQuestionReq)(nil), "api.QueryQuestionReq")
	proto.RegisterType((*QueryQuestionReply)(nil), "api.QueryQuestionReply")
	proto.RegisterType((*CreateHomeWorkReq)(nil), "api.CreateHomeWorkReq")
	proto.RegisterType((*CreateHomeWorkReply)(nil), "api.CreateHomeWorkReply")
	proto.RegisterType((*QueryMyHomeWorkReq)(nil), "api.QueryMyHomeWorkReq")
	proto.RegisterType((*QuestionInfo)(nil), "api.QuestionInfo")
	proto.RegisterType((*HomeWorkInfo)(nil), "api.HomeWorkInfo")
	proto.RegisterType((*QueryMyHomeWorkReply)(nil), "api.QueryMyHomeWorkReply")
	proto.RegisterType((*DoHomeWorkInfo)(nil), "api.DoHomeWorkInfo")
	proto.RegisterType((*DoHomeWorkReq)(nil), "api.DoHomeWorkReq")
	proto.RegisterType((*QueryAnswerRecordReq)(nil), "api.QueryAnswerRecordReq")
	proto.RegisterType((*UserAnswerInfo)(nil), "api.UserAnswerInfo")
	proto.RegisterType((*AllUserAnswerInfo)(nil), "api.AllUserAnswerInfo")
	proto.RegisterType((*QueryAnswerRecordReply)(nil), "api.QueryAnswerRecordReply")
	proto.RegisterType((*QueryHomeWorkInClassReply)(nil), "api.QueryHomeWorkInClassReply")
	proto.RegisterType((*CreatePracticeSummaryReq)(nil), "api.CreatePracticeSummaryReq")
	proto.RegisterType((*CreatePracticeSummaryReply)(nil), "api.CreatePracticeSummaryReply")
	proto.RegisterType((*QueryPracticeSummaryReq)(nil), "api.QueryPracticeSummaryReq")
	proto.RegisterType((*PracticeSummaryInfo)(nil), "api.PracticeSummaryInfo")
	proto.RegisterType((*QuestionPre)(nil), "api.QuestionPre")
	proto.RegisterType((*PracticeSummaryDetailInfo)(nil), "api.PracticeSummaryDetailInfo")
	proto.RegisterType((*QueryMyPracticeSummaryReq)(nil), "api.QueryMyPracticeSummaryReq")
	proto.RegisterType((*QueryMyPracticeSummaryReply)(nil), "api.QueryMyPracticeSummaryReply")
	proto.RegisterType((*ControllQuestionInPSReq)(nil), "api.ControllQuestionInPSReq")
	proto.RegisterEnum("api.PracticeSummaryType", PracticeSummaryType_name, PracticeSummaryType_value)
}
func (m *CRqQueryMyQuestionInfoBySubject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CRqQueryMyQuestionInfoBySubject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if len(m.Subject) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Subject)))
		i += copy(dAtA[i:], m.Subject)
	}
	if m.Endtime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Endtime))
	}
	return i, nil
}

func (m *CRpMyQuestionInfoBySubject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CRpMyQuestionInfoBySubject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Knowledgenodes) > 0 {
		for _, s := range m.Knowledgenodes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CreateQuestionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateQuestionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Kind))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Subject) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Subject)))
		i += copy(dAtA[i:], m.Subject)
	}
	if len(m.Course) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Course)))
		i += copy(dAtA[i:], m.Course)
	}
	if len(m.Knowledge) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Knowledge)))
		i += copy(dAtA[i:], m.Knowledge)
	}
	return i, nil
}

func (m *QuestionInfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuestionInfoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Kind))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Subject) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Subject)))
		i += copy(dAtA[i:], m.Subject)
	}
	if len(m.Course) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Course)))
		i += copy(dAtA[i:], m.Course)
	}
	if len(m.Knowledge) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Knowledge)))
		i += copy(dAtA[i:], m.Knowledge)
	}
	return i, nil
}

func (m *QueryQuestionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryQuestionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Kind))
	}
	if len(m.Subject) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Subject)))
		i += copy(dAtA[i:], m.Subject)
	}
	if len(m.Course) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Course)))
		i += copy(dAtA[i:], m.Course)
	}
	if len(m.Knowledge) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Knowledge)))
		i += copy(dAtA[i:], m.Knowledge)
	}
	return i, nil
}

func (m *QueryQuestionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryQuestionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questions) > 0 {
		for _, msg := range m.Questions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateHomeWorkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateHomeWorkReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Classid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Classid)))
		i += copy(dAtA[i:], m.Classid)
	}
	if len(m.Students) > 0 {
		for _, s := range m.Students {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Questions) > 0 {
		for _, s := range m.Questions {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CreateHomeWorkReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateHomeWorkReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homeworkid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Homeworkid)))
		i += copy(dAtA[i:], m.Homeworkid)
	}
	return i, nil
}

func (m *QueryMyHomeWorkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMyHomeWorkReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Classid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Classid)))
		i += copy(dAtA[i:], m.Classid)
	}
	return i, nil
}

func (m *QuestionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuestionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questionid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Questionid)))
		i += copy(dAtA[i:], m.Questionid)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Kind))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *HomeWorkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HomeWorkInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homeworkid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Homeworkid)))
		i += copy(dAtA[i:], m.Homeworkid)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Questions) > 0 {
		for _, msg := range m.Questions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryMyHomeWorkReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMyHomeWorkReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homework) > 0 {
		for _, msg := range m.Homework {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoHomeWorkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoHomeWorkInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questionid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Questionid)))
		i += copy(dAtA[i:], m.Questionid)
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DoHomeWorkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoHomeWorkReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homeworkid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Homeworkid)))
		i += copy(dAtA[i:], m.Homeworkid)
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Answer) > 0 {
		for _, msg := range m.Answer {
			dAtA[i] = 0x22
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryAnswerRecordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnswerRecordReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homeworkid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Homeworkid)))
		i += copy(dAtA[i:], m.Homeworkid)
	}
	return i, nil
}

func (m *UserAnswerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAnswerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AllUserAnswerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllUserAnswerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questionid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Questionid)))
		i += copy(dAtA[i:], m.Questionid)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Rightanswer) > 0 {
		for _, s := range m.Rightanswer {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Alluseranswer) > 0 {
		for _, msg := range m.Alluseranswer {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryAnswerRecordReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnswerRecordReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homeworkrecord) > 0 {
		for _, msg := range m.Homeworkrecord {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryHomeWorkInClassReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryHomeWorkInClassReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Homework) > 0 {
		for _, msg := range m.Homework {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreatePracticeSummaryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePracticeSummaryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Ownerid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Ownerid)))
		i += copy(dAtA[i:], m.Ownerid)
	}
	if len(m.Classid) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Classid)))
		i += copy(dAtA[i:], m.Classid)
	}
	if m.Pstype != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Pstype))
	}
	if len(m.Introduction) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Introduction)))
		i += copy(dAtA[i:], m.Introduction)
	}
	if len(m.Ownername) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Ownername)))
		i += copy(dAtA[i:], m.Ownername)
	}
	return i, nil
}

func (m *CreatePracticeSummaryReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePracticeSummaryReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Practicesummaryid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Practicesummaryid)))
		i += copy(dAtA[i:], m.Practicesummaryid)
	}
	return i, nil
}

func (m *QueryPracticeSummaryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPracticeSummaryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Practicesummaryid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Practicesummaryid)))
		i += copy(dAtA[i:], m.Practicesummaryid)
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *PracticeSummaryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PracticeSummaryInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Practicesummaryid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Practicesummaryid)))
		i += copy(dAtA[i:], m.Practicesummaryid)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Introduction) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Introduction)))
		i += copy(dAtA[i:], m.Introduction)
	}
	if m.Questionnumbers != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Questionnumbers))
	}
	if m.Pstype != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Pstype))
	}
	if len(m.Ownername) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Ownername)))
		i += copy(dAtA[i:], m.Ownername)
	}
	if len(m.Coursename) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Coursename)))
		i += copy(dAtA[i:], m.Coursename)
	}
	return i, nil
}

func (m *QuestionPre) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuestionPre) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questionid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Questionid)))
		i += copy(dAtA[i:], m.Questionid)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Kind))
	}
	if len(m.Knowledgename) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Knowledgename)))
		i += copy(dAtA[i:], m.Knowledgename)
	}
	return i, nil
}

func (m *PracticeSummaryDetailInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PracticeSummaryDetailInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Questions) > 0 {
		for _, msg := range m.Questions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Currentpage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Currentpage))
	}
	if m.Totalpage != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Totalpage))
	}
	return i, nil
}

func (m *QueryMyPracticeSummaryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMyPracticeSummaryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *QueryMyPracticeSummaryReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMyPracticeSummaryReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Practicesummary) > 0 {
		for _, msg := range m.Practicesummary {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuestion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Currentpage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Currentpage))
	}
	if m.Totalpage != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(m.Totalpage))
	}
	return i, nil
}

func (m *ControllQuestionInPSReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllQuestionInPSReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Practicesummaryid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuestion(dAtA, i, uint64(len(m.Practicesummaryid)))
		i += copy(dAtA[i:], m.Practicesummaryid)
	}
	if len(m.Questions) > 0 {
		for _, s := range m.Questions {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintQuestion(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CRqQueryMyQuestionInfoBySubject) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Endtime != 0 {
		n += 1 + sovQuestion(uint64(m.Endtime))
	}
	return n
}

func (m *CRpMyQuestionInfoBySubject) Size() (n int) {
	var l int
	_ = l
	if len(m.Knowledgenodes) > 0 {
		for _, s := range m.Knowledgenodes {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *CreateQuestionReq) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovQuestion(uint64(m.Kind))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Course)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Knowledge)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QuestionInfoReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovQuestion(uint64(m.Kind))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Course)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Knowledge)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QueryQuestionReq) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovQuestion(uint64(m.Kind))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Course)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Knowledge)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QueryQuestionReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *CreateHomeWorkReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Classid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Students) > 0 {
		for _, s := range m.Students {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if len(m.Questions) > 0 {
		for _, s := range m.Questions {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *CreateHomeWorkReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Homeworkid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QueryMyHomeWorkReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Classid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QuestionInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Questionid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovQuestion(uint64(m.Kind))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *HomeWorkInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Homeworkid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *QueryMyHomeWorkReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Homework) > 0 {
		for _, e := range m.Homework {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *DoHomeWorkInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Questionid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *DoHomeWorkReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Homeworkid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Answer) > 0 {
		for _, e := range m.Answer {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *QueryAnswerRecordReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Homeworkid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *UserAnswerInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Answer) > 0 {
		for _, s := range m.Answer {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *AllUserAnswerInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Questionid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Option) > 0 {
		for _, s := range m.Option {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if len(m.Rightanswer) > 0 {
		for _, s := range m.Rightanswer {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if len(m.Alluseranswer) > 0 {
		for _, e := range m.Alluseranswer {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *QueryAnswerRecordReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Homeworkrecord) > 0 {
		for _, e := range m.Homeworkrecord {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *QueryHomeWorkInClassReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Homework) > 0 {
		for _, e := range m.Homework {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func (m *CreatePracticeSummaryReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Ownerid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Classid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Pstype != 0 {
		n += 1 + sovQuestion(uint64(m.Pstype))
	}
	l = len(m.Introduction)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Ownername)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *CreatePracticeSummaryReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Practicesummaryid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QueryPracticeSummaryReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Practicesummaryid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovQuestion(uint64(m.Page))
	}
	return n
}

func (m *PracticeSummaryInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Practicesummaryid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Introduction)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Questionnumbers != 0 {
		n += 1 + sovQuestion(uint64(m.Questionnumbers))
	}
	if m.Pstype != 0 {
		n += 1 + sovQuestion(uint64(m.Pstype))
	}
	l = len(m.Ownername)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	l = len(m.Coursename)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *QuestionPre) Size() (n int) {
	var l int
	_ = l
	l = len(m.Questionid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovQuestion(uint64(m.Kind))
	}
	l = len(m.Knowledgename)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	return n
}

func (m *PracticeSummaryDetailInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Currentpage != 0 {
		n += 1 + sovQuestion(uint64(m.Currentpage))
	}
	if m.Totalpage != 0 {
		n += 1 + sovQuestion(uint64(m.Totalpage))
	}
	return n
}

func (m *QueryMyPracticeSummaryReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovQuestion(uint64(m.Page))
	}
	return n
}

func (m *QueryMyPracticeSummaryReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Practicesummary) > 0 {
		for _, e := range m.Practicesummary {
			l = e.Size()
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	if m.Currentpage != 0 {
		n += 1 + sovQuestion(uint64(m.Currentpage))
	}
	if m.Totalpage != 0 {
		n += 1 + sovQuestion(uint64(m.Totalpage))
	}
	return n
}

func (m *ControllQuestionInPSReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Practicesummaryid)
	if l > 0 {
		n += 1 + l + sovQuestion(uint64(l))
	}
	if len(m.Questions) > 0 {
		for _, s := range m.Questions {
			l = len(s)
			n += 1 + l + sovQuestion(uint64(l))
		}
	}
	return n
}

func sovQuestion(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozQuestion(x uint64) (n int) {
	return sovQuestion(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CRqQueryMyQuestionInfoBySubject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CRqQueryMyQuestionInfoBySubject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CRqQueryMyQuestionInfoBySubject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endtime", wireType)
			}
			m.Endtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Endtime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CRpMyQuestionInfoBySubject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CRpMyQuestionInfoBySubject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CRpMyQuestionInfoBySubject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Knowledgenodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Knowledgenodes = append(m.Knowledgenodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateQuestionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateQuestionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateQuestionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = append(m.Option, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answer = append(m.Answer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Course = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Knowledge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Knowledge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuestionInfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuestionInfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuestionInfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = append(m.Option, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answer = append(m.Answer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Course = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Knowledge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Knowledge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryQuestionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryQuestionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryQuestionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Course = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Knowledge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Knowledge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryQuestionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryQuestionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryQuestionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &QuestionInfoReply{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateHomeWorkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateHomeWorkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateHomeWorkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Students", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Students = append(m.Students, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateHomeWorkReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateHomeWorkReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateHomeWorkReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homeworkid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homeworkid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMyHomeWorkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMyHomeWorkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMyHomeWorkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuestionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuestionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuestionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questionid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = append(m.Option, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HomeWorkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HomeWorkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HomeWorkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homeworkid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homeworkid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &QuestionInfo{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMyHomeWorkReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMyHomeWorkReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMyHomeWorkReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homework", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homework = append(m.Homework, &HomeWorkInfo{})
			if err := m.Homework[len(m.Homework)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoHomeWorkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoHomeWorkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoHomeWorkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questionid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answer = append(m.Answer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoHomeWorkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoHomeWorkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoHomeWorkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homeworkid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homeworkid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answer = append(m.Answer, &DoHomeWorkInfo{})
			if err := m.Answer[len(m.Answer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAnswerRecordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnswerRecordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnswerRecordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homeworkid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homeworkid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAnswerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAnswerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAnswerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answer = append(m.Answer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllUserAnswerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllUserAnswerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllUserAnswerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questionid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = append(m.Option, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rightanswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rightanswer = append(m.Rightanswer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alluseranswer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alluseranswer = append(m.Alluseranswer, &UserAnswerInfo{})
			if err := m.Alluseranswer[len(m.Alluseranswer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAnswerRecordReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnswerRecordReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnswerRecordReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homeworkrecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homeworkrecord = append(m.Homeworkrecord, &AllUserAnswerInfo{})
			if err := m.Homeworkrecord[len(m.Homeworkrecord)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryHomeWorkInClassReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryHomeWorkInClassReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryHomeWorkInClassReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homework", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homework = append(m.Homework, &HomeWorkInfo{})
			if err := m.Homework[len(m.Homework)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePracticeSummaryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePracticeSummaryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePracticeSummaryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ownerid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ownerid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pstype", wireType)
			}
			m.Pstype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pstype |= (PracticeSummaryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Introduction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Introduction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ownername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ownername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePracticeSummaryReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePracticeSummaryReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePracticeSummaryReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Practicesummaryid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Practicesummaryid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPracticeSummaryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPracticeSummaryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPracticeSummaryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Practicesummaryid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Practicesummaryid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PracticeSummaryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PracticeSummaryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PracticeSummaryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Practicesummaryid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Practicesummaryid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Introduction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Introduction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionnumbers", wireType)
			}
			m.Questionnumbers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Questionnumbers |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pstype", wireType)
			}
			m.Pstype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pstype |= (PracticeSummaryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ownername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ownername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coursename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coursename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuestionPre) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuestionPre: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuestionPre: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questionid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Knowledgename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Knowledgename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PracticeSummaryDetailInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PracticeSummaryDetailInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PracticeSummaryDetailInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &QuestionPre{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currentpage", wireType)
			}
			m.Currentpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Currentpage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Totalpage", wireType)
			}
			m.Totalpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Totalpage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMyPracticeSummaryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMyPracticeSummaryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMyPracticeSummaryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMyPracticeSummaryReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMyPracticeSummaryReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMyPracticeSummaryReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Practicesummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Practicesummary = append(m.Practicesummary, &PracticeSummaryInfo{})
			if err := m.Practicesummary[len(m.Practicesummary)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currentpage", wireType)
			}
			m.Currentpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Currentpage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Totalpage", wireType)
			}
			m.Totalpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Totalpage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllQuestionInPSReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllQuestionInPSReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllQuestionInPSReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Practicesummaryid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Practicesummaryid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuestion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuestion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuestion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuestion(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuestion
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuestion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthQuestion
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowQuestion
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipQuestion(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthQuestion = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuestion   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api/question.proto", fileDescriptorQuestion) }

var fileDescriptorQuestion = []byte{
	// 1684 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0x4f, 0x6f, 0x23, 0xc5,
	0x12, 0xcf, 0x78, 0xb2, 0x4e, 0x52, 0x49, 0x1c, 0xbb, 0xf3, 0xcf, 0xf1, 0xee, 0x66, 0xa2, 0x7e,
	0x7f, 0xb4, 0xfb, 0xf4, 0x5e, 0x2c, 0xe5, 0xbd, 0x27, 0x21, 0x10, 0x0b, 0xb1, 0x1d, 0x76, 0x17,
	0x12, 0x36, 0xdb, 0xc9, 0x0a, 0x2d, 0x5a, 0x01, 0x13, 0xbb, 0x37, 0x19, 0x62, 0xcf, 0x38, 0x33,
	0x63, 0x22, 0x1f, 0xb9, 0xf2, 0x05, 0x80, 0x6f, 0x80, 0xc4, 0x09, 0x6e, 0x5c, 0x11, 0x07, 0x10,
	0x07, 0xe0, 0x0b, 0x58, 0x28, 0x5c, 0x10, 0xdc, 0xfc, 0x09, 0x50, 0xff, 0x19, 0x4f, 0xcf, 0x78,
	0x1c, 0xdb, 0xd1, 0x2e, 0xdc, 0xc6, 0x5d, 0xd5, 0xd5, 0x5d, 0xbf, 0xfa, 0x55, 0x75, 0x75, 0x1b,
	0x90, 0xd9, 0xb4, 0x8a, 0x67, 0x2d, 0xea, 0xf9, 0x96, 0x63, 0x6f, 0x36, 0x5d, 0xc7, 0x77, 0x90,
	0x6e, 0x36, 0xad, 0xc2, 0x7f, 0x8e, 0x2d, 0xff, 0xa4, 0x75, 0xb4, 0x59, 0x75, 0x1a, 0xc5, 0x63,
	0xe7, 0xd8, 0x29, 0x72, 0xd9, 0x51, 0xeb, 0x29, 0xff, 0xc5, 0x7f, 0xf0, 0x2f, 0x31, 0xa7, 0x50,
	0x3e, 0xb5, 0x9d, 0xf3, 0x3a, 0xad, 0x1d, 0xd3, 0x86, 0xd9, 0x7c, 0xf7, 0xc8, 0xac, 0x9e, 0x52,
	0xbb, 0x56, 0x6c, 0x58, 0x55, 0xd7, 0xf1, 0xa8, 0xfb, 0x81, 0x55, 0xa5, 0x5e, 0x51, 0x55, 0x29,
	0xb6, 0x3c, 0xea, 0x16, 0xd9, 0xe2, 0xec, 0x43, 0x1a, 0xd9, 0x19, 0xd7, 0x48, 0xb5, 0x6e, 0x7a,
	0x1e, 0xb7, 0xc2, 0xbf, 0x84, 0x19, 0xfc, 0xa1, 0x06, 0x46, 0x99, 0x9c, 0x3d, 0x6c, 0x51, 0xb7,
	0xbd, 0xd7, 0x7e, 0x28, 0x9d, 0xbb, 0x6f, 0x3f, 0x75, 0x4a, 0xed, 0x83, 0xd6, 0xd1, 0xfb, 0xb4,
	0xea, 0xa3, 0x2c, 0xe8, 0x2d, 0xab, 0x96, 0xd7, 0x36, 0xb4, 0x5b, 0x33, 0x84, 0x7d, 0xa2, 0x7f,
	0xc0, 0x94, 0x27, 0x84, 0xf9, 0x14, 0x1b, 0x2d, 0xcd, 0xfe, 0xd6, 0x31, 0x82, 0x21, 0x12, 0x7c,
	0x30, 0x35, 0x6a, 0xd7, 0x7c, 0xab, 0x41, 0xf3, 0xfa, 0x86, 0x76, 0x4b, 0x17, 0x6a, 0x72, 0x88,
	0x04, 0x1f, 0xb8, 0x02, 0x85, 0x32, 0x69, 0x0e, 0x5a, 0xfd, 0x9f, 0x90, 0xe9, 0xf9, 0x61, 0x3b,
	0x35, 0xea, 0xe5, 0xb5, 0x0d, 0xfd, 0xd6, 0x0c, 0x89, 0x8d, 0xe2, 0xef, 0x52, 0x90, 0x2b, 0xbb,
	0xd4, 0xf4, 0x69, 0x60, 0x87, 0xd0, 0x33, 0xf4, 0x37, 0x98, 0x3c, 0xb5, 0x6c, 0xb1, 0x79, 0xbd,
	0xb4, 0xd0, 0xed, 0x18, 0xb3, 0x4f, 0x1d, 0xb7, 0xf1, 0x22, 0x66, 0xa3, 0x98, 0x70, 0x21, 0xfa,
	0x37, 0x4c, 0x55, 0x1d, 0xdb, 0xa7, 0x76, 0xe0, 0x0e, 0xea, 0x76, 0x8c, 0x8c, 0xd0, 0x93, 0x02,
	0x4c, 0x02, 0x15, 0x74, 0x1b, 0xd2, 0x4e, 0x93, 0xd9, 0xcf, 0xeb, 0x6c, 0x23, 0xa5, 0x5c, 0xb7,
	0x63, 0xcc, 0x0b, 0x65, 0x31, 0x8e, 0x89, 0x54, 0x60, 0xaa, 0xa6, 0xed, 0x9d, 0x53, 0x37, 0x3f,
	0x19, 0x57, 0x15, 0xe3, 0x98, 0x48, 0x05, 0xb6, 0x87, 0x00, 0xd2, 0x6b, 0xf1, 0x3d, 0x48, 0x01,
	0x0e, 0x91, 0xbd, 0x0d, 0xe9, 0xaa, 0xd3, 0x72, 0x3d, 0x9a, 0x4f, 0x73, 0x65, 0xc5, 0xb0, 0x18,
	0xc7, 0x44, 0x2a, 0xa0, 0x2d, 0x98, 0xe9, 0x21, 0x95, 0x9f, 0xe2, 0xda, 0x4b, 0xdd, 0x8e, 0x91,
	0x95, 0x30, 0x04, 0x22, 0x4c, 0x42, 0x35, 0xfc, 0x6b, 0x0a, 0x72, 0x6a, 0x34, 0x08, 0x6d, 0xd6,
	0xdb, 0xe8, 0x26, 0xa4, 0x02, 0x1a, 0x94, 0xe6, 0xbb, 0x1d, 0x63, 0x46, 0x98, 0xb0, 0x6a, 0x98,
	0xa4, 0xac, 0x5a, 0x0f, 0xea, 0xd4, 0x88, 0x50, 0xeb, 0xe3, 0x40, 0x3d, 0x39, 0x3a, 0xd4, 0xd7,
	0xc6, 0x80, 0x3a, 0x3d, 0x0e, 0xd4, 0x53, 0x63, 0x41, 0x3d, 0x3d, 0x1a, 0xd4, 0xdf, 0x68, 0x90,
	0xe5, 0xd9, 0x77, 0x15, 0xd6, 0x46, 0x93, 0x70, 0x44, 0x37, 0xf4, 0xb1, 0xdc, 0x98, 0x1c, 0xcd,
	0x8d, 0xf7, 0x00, 0xc5, 0xbc, 0x60, 0x8c, 0x79, 0x1d, 0x66, 0x82, 0x7a, 0x29, 0xd2, 0x76, 0x76,
	0x6b, 0x65, 0xd3, 0x6c, 0x5a, 0x9b, 0x7d, 0xe4, 0x52, 0x57, 0xe8, 0x4d, 0xc1, 0x24, 0x9c, 0x8e,
	0xbf, 0xd7, 0x82, 0xfc, 0xbe, 0xe7, 0x34, 0xe8, 0x5b, 0x8e, 0x7b, 0x2a, 0x91, 0xb2, 0xcd, 0x06,
	0x95, 0xac, 0x54, 0x90, 0x62, 0xa3, 0x98, 0x70, 0x21, 0x27, 0x1d, 0xab, 0x79, 0x56, 0x2d, 0x21,
	0xbf, 0x85, 0x80, 0x91, 0x4e, 0x7c, 0xa1, 0x22, 0x4c, 0x7b, 0x7e, 0xab, 0x46, 0x6d, 0xdf, 0x93,
	0x19, 0xbe, 0xd8, 0xed, 0x18, 0x0b, 0x12, 0x58, 0x29, 0xc1, 0xa4, 0xa7, 0xc4, 0xf0, 0x0a, 0xbd,
	0x14, 0x44, 0x1d, 0xea, 0xcd, 0x2e, 0x2c, 0xc6, 0x9d, 0x61, 0x80, 0xfd, 0x1f, 0xe0, 0xc4, 0x69,
	0xd0, 0x73, 0xc7, 0x3d, 0xed, 0xa5, 0xda, 0x72, 0xb7, 0x63, 0xe4, 0x84, 0xad, 0x50, 0x86, 0x89,
	0xa2, 0x88, 0x1b, 0x12, 0xfd, 0xbd, 0xb6, 0x8a, 0xcd, 0x6d, 0x48, 0xb3, 0x03, 0xa3, 0x67, 0x48,
	0x09, 0xb9, 0x18, 0xc7, 0x44, 0x2a, 0x8c, 0x87, 0x10, 0xfe, 0x5a, 0x83, 0x39, 0x35, 0x82, 0xe8,
	0x7f, 0x00, 0x81, 0x6b, 0xbd, 0xd5, 0x22, 0x10, 0x48, 0x11, 0x26, 0x8a, 0xde, 0x5f, 0x5b, 0x30,
	0xf0, 0x17, 0x1a, 0xcc, 0x05, 0x68, 0x71, 0x27, 0xae, 0x86, 0x7d, 0x8f, 0x81, 0xa9, 0xcb, 0x18,
	0xb8, 0xa3, 0x52, 0x44, 0xe7, 0x89, 0x90, 0xeb, 0x4b, 0x84, 0xe1, 0xac, 0x79, 0x1b, 0x96, 0xfa,
	0xe2, 0xcc, 0x68, 0x53, 0x82, 0xe9, 0x60, 0x47, 0x32, 0xcd, 0x84, 0x75, 0xd5, 0x3f, 0x95, 0xc5,
	0x81, 0x32, 0x26, 0xbd, 0x79, 0xd8, 0x85, 0x4c, 0xc5, 0x89, 0x03, 0xd2, 0x17, 0x55, 0x05, 0x90,
	0x50, 0x16, 0x0d, 0x6b, 0x58, 0x89, 0x53, 0x43, 0x2a, 0x31, 0xbe, 0xd0, 0x60, 0x3e, 0x5c, 0x94,
	0x71, 0xf6, 0x8a, 0x41, 0x08, 0xa9, 0x9e, 0x1a, 0x46, 0xf5, 0x22, 0x4c, 0xb3, 0x2f, 0x1e, 0x33,
	0xc1, 0x28, 0x05, 0x98, 0x40, 0x82, 0x49, 0x4f, 0x09, 0xdd, 0x89, 0x1c, 0xe2, 0xb3, 0x5b, 0x8b,
	0x1c, 0xda, 0x28, 0x56, 0x97, 0x39, 0xb9, 0x27, 0x83, 0xb6, 0xcd, 0x7f, 0x12, 0x5a, 0x75, 0xdc,
	0xda, 0xd5, 0x5d, 0xc5, 0x1f, 0x6b, 0x90, 0x79, 0xe4, 0x51, 0x57, 0x98, 0xe3, 0x81, 0x52, 0x5d,
	0xd2, 0x46, 0x71, 0x69, 0x0c, 0xb8, 0xc2, 0x68, 0xea, 0xc3, 0xa2, 0xf9, 0x65, 0x0a, 0x72, 0xdb,
	0xf5, 0x7a, 0x6c, 0x73, 0x57, 0x64, 0xd1, 0x73, 0xeb, 0xc9, 0x5e, 0x80, 0x59, 0xd7, 0x3a, 0x3e,
	0xf1, 0x23, 0x8d, 0xd9, 0x4a, 0xb7, 0x63, 0x20, 0xa1, 0xaf, 0x08, 0x31, 0x51, 0x55, 0xd1, 0x01,
	0xcc, 0x9b, 0xf5, 0x3a, 0xc3, 0x45, 0xe9, 0x34, 0x02, 0x3e, 0x44, 0xbd, 0x2e, 0xe5, 0xbb, 0x1d,
	0x63, 0x49, 0xc2, 0xa4, 0xce, 0xc1, 0x24, 0x6a, 0x03, 0x7b, 0xb0, 0x92, 0xc0, 0x0e, 0x96, 0xd4,
	0x8f, 0x21, 0x13, 0x84, 0xdd, 0xe5, 0xc3, 0x91, 0x13, 0xb4, 0x0f, 0xe8, 0xd2, 0x5a, 0xb7, 0x63,
	0x2c, 0x47, 0xb9, 0x23, 0xe6, 0x61, 0x12, 0x33, 0x84, 0x29, 0xac, 0xf1, 0x45, 0x43, 0x0a, 0x97,
	0x59, 0x69, 0x17, 0xeb, 0xde, 0x1b, 0xa5, 0x98, 0x5c, 0xb2, 0x58, 0x58, 0x52, 0x7e, 0x4a, 0x41,
	0x5e, 0x9c, 0x72, 0xfb, 0xae, 0x59, 0xf5, 0xad, 0x2a, 0x3d, 0x68, 0x35, 0x1a, 0xa6, 0xdb, 0x1e,
	0xe7, 0xe4, 0x76, 0xce, 0x6d, 0x85, 0xa9, 0x0a, 0x0b, 0xa4, 0x00, 0x93, 0x40, 0x45, 0x3d, 0xc5,
	0xf4, 0xe1, 0xe7, 0x7c, 0x19, 0xd2, 0x4d, 0xcf, 0x6f, 0x37, 0x45, 0x8f, 0x93, 0xd9, 0xca, 0x73,
	0x2f, 0x63, 0x3b, 0x3d, 0x6c, 0x37, 0xa9, 0xca, 0x26, 0x31, 0x03, 0x13, 0x39, 0x15, 0xbd, 0x04,
	0x73, 0x96, 0xed, 0xbb, 0x4e, 0xad, 0x55, 0xe5, 0xf4, 0x13, 0xbd, 0xfb, 0x6a, 0xb7, 0x63, 0x2c,
	0xca, 0xee, 0x58, 0x91, 0x62, 0x12, 0x51, 0x66, 0x8d, 0x03, 0xdf, 0x3a, 0xc7, 0x21, 0x1d, 0x3f,
	0x35, 0x7b, 0x22, 0x4c, 0x42, 0x35, 0x7c, 0x02, 0x85, 0x01, 0x90, 0x8a, 0x86, 0x2b, 0xd7, 0x94,
	0xe3, 0x9e, 0x18, 0xef, 0xe5, 0xdc, 0x8d, 0x6e, 0xc7, 0xc8, 0x4b, 0x27, 0xe2, 0x2a, 0x98, 0xf4,
	0x4f, 0xc3, 0x1f, 0x69, 0xb0, 0xca, 0x59, 0x92, 0x10, 0xbc, 0x67, 0xb8, 0x0e, 0x23, 0x42, 0xd3,
	0x3c, 0xa6, 0xfd, 0x6d, 0x00, 0x1b, 0xc5, 0x84, 0x0b, 0xf1, 0x57, 0x3a, 0x2c, 0xc6, 0xf6, 0xc1,
	0xab, 0xcb, 0x33, 0xde, 0xc8, 0xf0, 0x93, 0x3c, 0x1e, 0x70, 0x7d, 0x9c, 0x80, 0x57, 0x60, 0x21,
	0x28, 0x71, 0x76, 0xab, 0x71, 0x44, 0x5d, 0x8f, 0x73, 0x4f, 0x2f, 0x15, 0xba, 0x1d, 0x63, 0x25,
	0x5a, 0x10, 0xa5, 0x02, 0x26, 0xf1, 0x29, 0x0a, 0x71, 0xaf, 0x5d, 0x9d, 0xb8, 0x57, 0xe0, 0x1e,
	0x2b, 0xe5, 0xe2, 0x8a, 0xc0, 0x27, 0x4d, 0xc5, 0x4b, 0x79, 0x28, 0xc3, 0x44, 0x51, 0xc4, 0x9f,
	0x69, 0x30, 0x1b, 0xf4, 0x39, 0xfb, 0x2e, 0x7d, 0x9e, 0xdd, 0xe2, 0x1d, 0x98, 0x0f, 0x9f, 0x05,
	0xc2, 0x13, 0x5e, 0xa9, 0xc6, 0x11, 0x31, 0x26, 0x51, 0x75, 0xfc, 0x83, 0x06, 0x6b, 0x31, 0x20,
	0x2b, 0xd4, 0x37, 0xad, 0x3a, 0x27, 0x5b, 0xa5, 0xff, 0x3a, 0x93, 0x8d, 0x74, 0x71, 0xfb, 0x2e,
	0x1d, 0xda, 0xc4, 0xb1, 0x03, 0xa8, 0xda, 0x72, 0x5d, 0x6a, 0xfb, 0x0a, 0xed, 0x95, 0x03, 0x48,
	0x11, 0x62, 0xa2, 0xaa, 0xb2, 0x98, 0xf9, 0x8e, 0x6f, 0xd6, 0xf9, 0x3c, 0xf1, 0xa2, 0xa2, 0xac,
	0xd6, 0x13, 0x61, 0x12, 0xaa, 0xe1, 0x53, 0x59, 0xea, 0xf7, 0x92, 0xd2, 0x78, 0x8c, 0x1b, 0xc2,
	0x48, 0x59, 0xfa, 0xbb, 0x06, 0xd7, 0x07, 0xad, 0xc6, 0xca, 0xd3, 0x3b, 0xb0, 0x10, 0x4b, 0x3b,
	0x09, 0x63, 0x22, 0x85, 0xf9, 0x41, 0xa3, 0x64, 0x46, 0x6c, 0x2a, 0x26, 0x71, 0x63, 0x7f, 0x32,
	0xb4, 0x9f, 0x6a, 0xb0, 0x5a, 0x76, 0x58, 0x7e, 0xd7, 0xeb, 0x61, 0x1f, 0xbf, 0x7f, 0xf0, 0xac,
	0x0b, 0x64, 0xe4, 0x7e, 0x99, 0x1a, 0xe9, 0x7e, 0xf9, 0xaf, 0x57, 0xfb, 0xca, 0x25, 0x2b, 0x08,
	0x68, 0x16, 0xa6, 0x2a, 0x3b, 0xaf, 0x6d, 0x3f, 0xda, 0x3d, 0xcc, 0x4e, 0xa0, 0x0c, 0x40, 0xf9,
	0xc1, 0xee, 0xee, 0x4e, 0xf9, 0xf0, 0xfe, 0x83, 0x37, 0xb3, 0x1a, 0x9a, 0x83, 0xe9, 0xbd, 0xfb,
	0x07, 0x87, 0xdb, 0x6f, 0xec, 0x1c, 0x64, 0x53, 0x5b, 0x9f, 0x4f, 0xc3, 0x74, 0xe0, 0x15, 0x7a,
	0x02, 0xb9, 0xbb, 0xd4, 0x8f, 0x3e, 0xd1, 0xa1, 0xbf, 0xf3, 0xa0, 0x0d, 0x79, 0x3d, 0x2c, 0x18,
	0x52, 0x6b, 0xd0, 0x03, 0x1f, 0x9e, 0x40, 0x25, 0xc8, 0x44, 0x5f, 0xee, 0x90, 0xe8, 0x71, 0xfa,
	0x9e, 0xf3, 0x0a, 0x03, 0x5e, 0x0f, 0xf0, 0x04, 0xda, 0x86, 0xf9, 0xc8, 0x03, 0x04, 0x5a, 0x0e,
	0x54, 0x23, 0x4f, 0x2b, 0x85, 0xd5, 0xa4, 0x61, 0x61, 0xa2, 0x12, 0x6c, 0x23, 0xe8, 0x74, 0x22,
	0xdb, 0x50, 0x6e, 0x29, 0x85, 0x7c, 0xe2, 0xb8, 0xb0, 0x72, 0x17, 0x16, 0x62, 0x77, 0x34, 0xa4,
	0xac, 0x19, 0xb9, 0xa1, 0x17, 0xd6, 0x92, 0x05, 0xc2, 0xd0, 0x26, 0x40, 0x78, 0xc9, 0x40, 0x28,
	0x76, 0xeb, 0x60, 0xd3, 0x81, 0x8f, 0xed, 0x34, 0x9a, 0x3e, 0xd3, 0xdf, 0xe3, 0x6f, 0x76, 0xd1,
	0x4e, 0x12, 0x29, 0x2b, 0xc4, 0xee, 0x1f, 0x85, 0xeb, 0x83, 0x44, 0x81, 0x1f, 0x4b, 0x49, 0x3d,
	0x22, 0x9a, 0x17, 0xbe, 0x8b, 0x7e, 0xf1, 0xac, 0xb0, 0x1e, 0x5a, 0x49, 0xea, 0x26, 0xf1, 0x04,
	0x7a, 0x0c, 0xcb, 0x89, 0x1d, 0x0b, 0xba, 0xa9, 0xa0, 0xd8, 0x5f, 0x9c, 0x02, 0xe2, 0x0c, 0x6c,
	0x76, 0xf0, 0x04, 0x3a, 0x84, 0x7c, 0x52, 0x87, 0xc2, 0xd9, 0x79, 0x23, 0xdc, 0x58, 0x82, 0xf1,
	0x81, 0x05, 0x87, 0x5b, 0x45, 0x77, 0xa9, 0x1f, 0xdf, 0xed, 0xe5, 0xf6, 0xd6, 0x93, 0xec, 0x85,
	0x47, 0x07, 0x9e, 0x40, 0x4f, 0x64, 0xa3, 0xdf, 0x57, 0x1a, 0xd1, 0xba, 0xca, 0x82, 0x04, 0xdb,
	0x1b, 0x97, 0xca, 0x05, 0x12, 0x2f, 0xc3, 0xc2, 0x76, 0xad, 0xa6, 0x56, 0x21, 0xb9, 0xe1, 0x01,
	0x05, 0x2a, 0xc6, 0x9d, 0x57, 0x20, 0x57, 0xa1, 0xf5, 0x30, 0xd7, 0xc6, 0x35, 0x50, 0xca, 0x7e,
	0x7b, 0xb1, 0xae, 0xfd, 0x78, 0xb1, 0xae, 0xfd, 0x7c, 0xb1, 0xae, 0x7d, 0xf2, 0xcb, 0xfa, 0xc4,
	0x51, 0x9a, 0xff, 0xc1, 0xf0, 0xdf, 0x3f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xec, 0x4b, 0x3f, 0xef,
	0x36, 0x19, 0x00, 0x00,
}
